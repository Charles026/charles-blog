[
  {
    "id": 1581393,
    "slug": "xeatlu",
    "title": "前端阶段性总结（五）：浏览器原理",
    "book_id": 199054,
    "book": {
      "id": 199054,
      "type": "Book",
      "slug": "blog",
      "name": "博客",
      "user_id": 155457,
      "description": "前端技术博客存档",
      "creator_id": 155457,
      "public": 1,
      "items_count": 15,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-04-23T09:00:45.336Z",
      "updated_at": "2019-04-23T09:00:45.000Z",
      "created_at": "2019-01-06T05:57:32.000Z",
      "namespace": "u46795/blog",
      "user": {
        "id": 155457,
        "type": "User",
        "login": "u46795",
        "name": "Nero",
        "description": "https://github.com/Ghostdar",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 5,
        "public_books_count": 5,
        "followers_count": 12,
        "following_count": 5,
        "created_at": "2018-08-04T03:45:56.000Z",
        "updated_at": "2019-04-30T15:08:36.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 155457,
    "creator": {
      "id": 155457,
      "type": "User",
      "login": "u46795",
      "name": "Nero",
      "description": "https://github.com/Ghostdar",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 5,
      "public_books_count": 5,
      "followers_count": 12,
      "following_count": 5,
      "created_at": "2018-08-04T03:45:56.000Z",
      "updated_at": "2019-04-30T15:08:36.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "",
    "body_draft": "",
    "body_html": "",
    "body_lake": "",
    "public": 1,
    "status": 0,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-23T14:08:07.000Z",
    "deleted_at": null,
    "created_at": "2019-04-23T08:59:50.000Z",
    "updated_at": "2019-04-23T14:08:07.000Z",
    "published_at": null,
    "first_published_at": null,
    "word_count": 0,
    "cover": null,
    "description": "引言： 转前端一年了，期间工作较忙，也没时间整理一些知识体系，此系列文章是对前端基础的一些回顾与总结。本文主要梳理一下web的宿主—浏览器的工作原理。一、前置知识在介绍浏览器之前，我们先简单了解一下计算机基础的一些基本概念，这对于理解下文有一定帮助。1. CPU 和 GPUCPU（Centra...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1313743,
    "slug": "twldmm",
    "title": "travis-ci自动部署到vps",
    "book_id": 199054,
    "book": {
      "id": 199054,
      "type": "Book",
      "slug": "blog",
      "name": "博客",
      "user_id": 155457,
      "description": "前端技术博客存档",
      "creator_id": 155457,
      "public": 1,
      "items_count": 15,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-04-23T09:00:45.336Z",
      "updated_at": "2019-04-23T09:00:45.000Z",
      "created_at": "2019-01-06T05:57:32.000Z",
      "namespace": "u46795/blog",
      "user": {
        "id": 155457,
        "type": "User",
        "login": "u46795",
        "name": "Nero",
        "description": "https://github.com/Ghostdar",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 5,
        "public_books_count": 5,
        "followers_count": 12,
        "following_count": 5,
        "created_at": "2018-08-04T03:45:56.000Z",
        "updated_at": "2019-04-30T15:08:36.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 155457,
    "creator": {
      "id": 155457,
      "type": "User",
      "login": "u46795",
      "name": "Nero",
      "description": "https://github.com/Ghostdar",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 5,
      "public_books_count": 5,
      "followers_count": 12,
      "following_count": 5,
      "created_at": "2018-08-04T03:45:56.000Z",
      "updated_at": "2019-04-30T15:08:36.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "<a name=\"78698512\"></a>\n### 一、环境：\n- vps环境：ubuntu\n\n<a name=\"1428a7ff\"></a>\n### 二、流程：\n\n<a name=\"6e8b1f3d\"></a>\n#### 1. 安装travis命令行工具：\n```\nsudo apt-get install ruby-dev  \n# 安装travis命令行工具，gem指令需要先安装ruby\nsudo gem install travis\n```\n\n<a name=\"cffd1de7\"></a>\n#### 2. 给用户sudo权限：\n```\nadduser hadoop\n\nchmod 740 /etc/sudoers\n\nsudo vim /etc/sudoers\n\n# User privilege specification 在root行后面增加\nhadoop    ALL=(ALL:ALL) ALL\n\n# 保存退出后，修改回文件权限\nchmod 440 /etc/sudoers\n```\n\n![image.png](https://cdn.nlark.com/yuque/0/2019/png/155457/1551427597144-b800e8d2-e834-44c6-b9b0-81035808b257.png#align=left&display=inline&height=445&name=image.png&originHeight=490&originWidth=858&size=40492&status=done&width=780)\n\n<a name=\"1aceaf37\"></a>\n#### 3. 配置ssh\n```\n# 生成ssh密钥对 注意密码要为空，Travis自动过程中才不会被输入密码步骤卡住，生成后目录 /home/hadoop/.ssh/id_rsa\nssh-keygen -t rsa\n# 设置.ssh目录为700\nchmod 700 ~/.ssh/\n# 设置.ssh目录下的文件为600\nchmod 600 ~/.ssh/*\n# 切换到.ssh/目录\ncd .ssh/\n# 将公钥内容添加到authorized_keys\ncat id_rsa.pub >> authorized_keys\n```\n\n<a name=\"ca658900\"></a>\n#### 4. 配置travis\n\n```\n# 在home目录下拉取Source仓库\ncd /home\ngit clone 你的仓库.git \n# cd到仓库根目录\n# 登录github帐号\ntravis login --auto\n\n# 在项目下新建.travis.yml\nvi .travis.yml\n\n# 生成加密公钥文件id_rsa.enc并自动增加解密行到.travis.yml文件；-r 指向GitHub的Source仓库\ntravis encrypt-file ~/.ssh/id_rsa --add -r Ghostdar/项目名称\n```\n\n<a name=\"8697adee\"></a>\n#### 5. 修改.travis.yml配置\n\n```\nlanguage: node_js\nnode_js:\n- '8'\nbranchs:\n  only:\n  - master\naddons:\n  ssh_known_hosts:\n  - 服务器IP\nbefore_install:\n- openssl aes-256-cbc -K $encrypted_2c31c2abd686_key -iv $encrypted_2c31c2abd686_iv -in id_rsa.enc -out ~/.ssh/id_rsa -d\n\ninstall:\n- npm install\n\nscript:\n- npm run build\n\nafter_success:\n- chmod 600 ~/.ssh/id_rsa\n- ssh hadoop@服务器IP -o StrictHostKeyChecking=no 'cd ~/项目文件夹 && git pull && npm install && npm run build'   #使用ssh连接服务器\n```\n<a name=\"d41d8cd9\"></a>\n#### \n<a name=\"036dc766\"></a>\n### 三、需要注意的点：\n\n- 确保git项目是通过ssh拉取的。\n- 确保github添加了ssh-key。\n",
    "body_draft": "",
    "body_html": "<h3 id=\"78698512\">一、环境：</h3><p>- vps环境：ubuntu</p><p><br /></p><h3 id=\"1428a7ff\">二、流程：</h3><p><br /></p><h4 id=\"6e8b1f3d\">1. 安装travis命令行工具：</h4><pre><code>sudo apt-get install ruby-dev  \n# 安装travis命令行工具，gem指令需要先安装ruby\nsudo gem install travis</code></pre><p><br /></p><h4 id=\"cffd1de7\">2. 给用户sudo权限：</h4><pre><code>adduser hadoop\n\nchmod 740 /etc/sudoers\n\nsudo vim /etc/sudoers\n\n# User privilege specification 在root行后面增加\nhadoop    ALL=(ALL:ALL) ALL\n\n# 保存退出后，修改回文件权限\nchmod 440 /etc/sudoers</code></pre><p><br /><img alt=\"image.png\" title=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/155457/1551427597144-b800e8d2-e834-44c6-b9b0-81035808b257.png#align=left&amp;display=inline&amp;height=445&amp;name=image.png&amp;originHeight=490&amp;originWidth=858&amp;size=40492&amp;status=done&amp;width=780\" style=\"max-width: 600px; width: 780px;\" /></p><p><br /></p><h4 id=\"1aceaf37\">3. 配置ssh</h4><pre><code># 生成ssh密钥对 注意密码要为空，Travis自动过程中才不会被输入密码步骤卡住，生成后目录 /home/hadoop/.ssh/id_rsa\nssh-keygen -t rsa\n# 设置.ssh目录为700\nchmod 700 ~/.ssh/\n# 设置.ssh目录下的文件为600\nchmod 600 ~/.ssh/*\n# 切换到.ssh/目录\ncd .ssh/\n# 将公钥内容添加到authorized_keys\ncat id_rsa.pub &gt;&gt; authorized_keys</code></pre><p><br /></p><h4 id=\"ca658900\">4. 配置travis</h4><p><br /></p><pre><code># 在home目录下拉取Source仓库\ncd /home\ngit clone 你的仓库.git \n# cd到仓库根目录\n# 登录github帐号\ntravis login --auto\n\n# 在项目下新建.travis.yml\nvi .travis.yml\n\n# 生成加密公钥文件id_rsa.enc并自动增加解密行到.travis.yml文件；-r 指向GitHub的Source仓库\ntravis encrypt-file ~/.ssh/id_rsa --add -r Ghostdar/项目名称</code></pre><p><br /></p><h4 id=\"8697adee\">5. 修改.travis.yml配置</h4><p><br /></p><pre><code>language: node_js\nnode_js:\n- '8'\nbranchs:\n  only:\n  - master\naddons:\n  ssh_known_hosts:\n  - 服务器IP\nbefore_install:\n- openssl aes-256-cbc -K $encrypted_2c31c2abd686_key -iv $encrypted_2c31c2abd686_iv -in id_rsa.enc -out ~/.ssh/id_rsa -d\n\ninstall:\n- npm install\n\nscript:\n- npm run build\n\nafter_success:\n- chmod 600 ~/.ssh/id_rsa\n- ssh hadoop@服务器IP -o StrictHostKeyChecking=no 'cd ~/项目文件夹 &amp;&amp; git pull &amp;&amp; npm install &amp;&amp; npm run build'   #使用ssh连接服务器</code></pre><h4 id=\"d41d8cd9\"><br /></h4><h3 id=\"036dc766\">三、需要注意的点：</h3><p><br /></p><ul><li>确保git项目是通过ssh拉取的。</li><li>确保github添加了ssh-key。</li></ul>",
    "body_lake": "<!doctype lake><h3 id=\"78698512\">一、环境：</h3><p>- vps环境：ubuntu</p><p><br /></p><h3 id=\"1428a7ff\">二、流程：</h3><p><br /></p><h4 id=\"6e8b1f3d\">1. 安装travis命令行工具：</h4><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22plain%22%2C%22code%22%3A%22sudo%20apt-get%20install%20ruby-dev%20%20%5Cn%23%20%E5%AE%89%E8%A3%85travis%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%EF%BC%8Cgem%E6%8C%87%E4%BB%A4%E9%9C%80%E8%A6%81%E5%85%88%E5%AE%89%E8%A3%85ruby%5Cnsudo%20gem%20install%20travis%22%7D\"></card><p><br /></p><h4 id=\"cffd1de7\">2. 给用户sudo权限：</h4><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22plain%22%2C%22code%22%3A%22adduser%20hadoop%5Cn%5Cnchmod%20740%20%2Fetc%2Fsudoers%5Cn%5Cnsudo%20vim%20%2Fetc%2Fsudoers%5Cn%5Cn%23%20User%20privilege%20specification%20%E5%9C%A8root%E8%A1%8C%E5%90%8E%E9%9D%A2%E5%A2%9E%E5%8A%A0%5Cnhadoop%20%20%20%20ALL%3D(ALL%3AALL)%20ALL%5Cn%5Cn%23%20%E4%BF%9D%E5%AD%98%E9%80%80%E5%87%BA%E5%90%8E%EF%BC%8C%E4%BF%AE%E6%94%B9%E5%9B%9E%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%5Cnchmod%20440%20%2Fetc%2Fsudoers%22%7D\"></card><p><br /><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F155457%2F1551427597144-b800e8d2-e834-44c6-b9b0-81035808b257.png%22%2C%22originWidth%22%3A858%2C%22originHeight%22%3A490%2C%22name%22%3A%22image.png%22%2C%22size%22%3A40492%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A780%2C%22height%22%3A445%7D\"></card></p><p><br /></p><h4 id=\"1aceaf37\">3. 配置ssh</h4><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22plain%22%2C%22code%22%3A%22%23%20%E7%94%9F%E6%88%90ssh%E5%AF%86%E9%92%A5%E5%AF%B9%20%E6%B3%A8%E6%84%8F%E5%AF%86%E7%A0%81%E8%A6%81%E4%B8%BA%E7%A9%BA%EF%BC%8CTravis%E8%87%AA%E5%8A%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%89%8D%E4%B8%8D%E4%BC%9A%E8%A2%AB%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81%E6%AD%A5%E9%AA%A4%E5%8D%A1%E4%BD%8F%EF%BC%8C%E7%94%9F%E6%88%90%E5%90%8E%E7%9B%AE%E5%BD%95%20%2Fhome%2Fhadoop%2F.ssh%2Fid_rsa%5Cnssh-keygen%20-t%20rsa%5Cn%23%20%E8%AE%BE%E7%BD%AE.ssh%E7%9B%AE%E5%BD%95%E4%B8%BA700%5Cnchmod%20700%20~%2F.ssh%2F%5Cn%23%20%E8%AE%BE%E7%BD%AE.ssh%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%BA600%5Cnchmod%20600%20~%2F.ssh%2F*%5Cn%23%20%E5%88%87%E6%8D%A2%E5%88%B0.ssh%2F%E7%9B%AE%E5%BD%95%5Cncd%20.ssh%2F%5Cn%23%20%E5%B0%86%E5%85%AC%E9%92%A5%E5%86%85%E5%AE%B9%E6%B7%BB%E5%8A%A0%E5%88%B0authorized_keys%5Cncat%20id_rsa.pub%20%3E%3E%20authorized_keys%22%7D\"></card><p><br /></p><h4 id=\"ca658900\">4. 配置travis</h4><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22plain%22%2C%22code%22%3A%22%23%20%E5%9C%A8home%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%8B%89%E5%8F%96Source%E4%BB%93%E5%BA%93%5Cncd%20%2Fhome%5Cngit%20clone%20%E4%BD%A0%E7%9A%84%E4%BB%93%E5%BA%93.git%20%5Cn%23%20cd%E5%88%B0%E4%BB%93%E5%BA%93%E6%A0%B9%E7%9B%AE%E5%BD%95%5Cn%23%20%E7%99%BB%E5%BD%95github%E5%B8%90%E5%8F%B7%5Cntravis%20login%20--auto%5Cn%5Cn%23%20%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%8B%E6%96%B0%E5%BB%BA.travis.yml%5Cnvi%20.travis.yml%5Cn%5Cn%23%20%E7%94%9F%E6%88%90%E5%8A%A0%E5%AF%86%E5%85%AC%E9%92%A5%E6%96%87%E4%BB%B6id_rsa.enc%E5%B9%B6%E8%87%AA%E5%8A%A8%E5%A2%9E%E5%8A%A0%E8%A7%A3%E5%AF%86%E8%A1%8C%E5%88%B0.travis.yml%E6%96%87%E4%BB%B6%EF%BC%9B-r%20%E6%8C%87%E5%90%91GitHub%E7%9A%84Source%E4%BB%93%E5%BA%93%5Cntravis%20encrypt-file%20~%2F.ssh%2Fid_rsa%20--add%20-r%20Ghostdar%2F%E9%A1%B9%E7%9B%AE%E5%90%8D%E7%A7%B0%22%7D\"></card><p><br /></p><h4 id=\"8697adee\">5. 修改.travis.yml配置</h4><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22plain%22%2C%22code%22%3A%22language%3A%20node_js%5Cnnode_js%3A%5Cn-%20'8'%5Cnbranchs%3A%5Cn%20%20only%3A%5Cn%20%20-%20master%5Cnaddons%3A%5Cn%20%20ssh_known_hosts%3A%5Cn%20%20-%20%E6%9C%8D%E5%8A%A1%E5%99%A8IP%5Cnbefore_install%3A%5Cn-%20openssl%20aes-256-cbc%20-K%20%24encrypted_2c31c2abd686_key%20-iv%20%24encrypted_2c31c2abd686_iv%20-in%20id_rsa.enc%20-out%20~%2F.ssh%2Fid_rsa%20-d%5Cn%5Cninstall%3A%5Cn-%20npm%20install%5Cn%5Cnscript%3A%5Cn-%20npm%20run%20build%5Cn%5Cnafter_success%3A%5Cn-%20chmod%20600%20~%2F.ssh%2Fid_rsa%5Cn-%20ssh%20hadoop%40%E6%9C%8D%E5%8A%A1%E5%99%A8IP%20-o%20StrictHostKeyChecking%3Dno%20'cd%20~%2F%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E5%A4%B9%20%26%26%20git%20pull%20%26%26%20npm%20install%20%26%26%20npm%20run%20build'%20%20%20%23%E4%BD%BF%E7%94%A8ssh%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%22%7D\"></card><h4 id=\"d41d8cd9\"><br /></h4><h3 id=\"036dc766\">三、需要注意的点：</h3><p><br /></p><ul><li>确保git项目是通过ssh拉取的。</li><li>确保github添加了ssh-key。</li></ul>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 1,
    "content_updated_at": "2019-03-01T09:29:42.000Z",
    "deleted_at": null,
    "created_at": "2019-03-01T08:02:10.000Z",
    "updated_at": "2019-03-08T02:37:20.000Z",
    "published_at": "2019-03-01T09:29:42.000Z",
    "first_published_at": "2019-03-01T09:29:42.000Z",
    "word_count": 410,
    "cover": null,
    "description": "一、环境：- vps环境：ubuntu二、流程：1. 安装travis命令行工具：sudo apt-get install ruby-dev   # 安装travis命令行工具，gem指令需要先安装ruby sudo gem install travis2. 给用户sudo权限：adduser...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1313739,
    "slug": "bw9poc",
    "title": "travis-ci 线上项目部署",
    "book_id": 199054,
    "book": {
      "id": 199054,
      "type": "Book",
      "slug": "blog",
      "name": "博客",
      "user_id": 155457,
      "description": "前端技术博客存档",
      "creator_id": 155457,
      "public": 1,
      "items_count": 15,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-04-23T09:00:45.336Z",
      "updated_at": "2019-04-23T09:00:45.000Z",
      "created_at": "2019-01-06T05:57:32.000Z",
      "namespace": "u46795/blog",
      "user": {
        "id": 155457,
        "type": "User",
        "login": "u46795",
        "name": "Nero",
        "description": "https://github.com/Ghostdar",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 5,
        "public_books_count": 5,
        "followers_count": 12,
        "following_count": 5,
        "created_at": "2018-08-04T03:45:56.000Z",
        "updated_at": "2019-04-30T15:08:36.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 155457,
    "creator": {
      "id": 155457,
      "type": "User",
      "login": "u46795",
      "name": "Nero",
      "description": "https://github.com/Ghostdar",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 5,
      "public_books_count": 5,
      "followers_count": 12,
      "following_count": 5,
      "created_at": "2018-08-04T03:45:56.000Z",
      "updated_at": "2019-04-30T15:08:36.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "",
    "body_draft": "",
    "body_html": "",
    "body_lake": "",
    "public": 1,
    "status": 0,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-03-01T08:01:37.000Z",
    "deleted_at": null,
    "created_at": "2019-03-01T08:01:35.000Z",
    "updated_at": "2019-03-01T08:02:02.000Z",
    "published_at": null,
    "first_published_at": null,
    "word_count": 0,
    "cover": null,
    "description": "",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1138567,
    "slug": "gdgo85",
    "title": "小程序初识--仿Vue.js中文论坛",
    "book_id": 199054,
    "book": {
      "id": 199054,
      "type": "Book",
      "slug": "blog",
      "name": "博客",
      "user_id": 155457,
      "description": "前端技术博客存档",
      "creator_id": 155457,
      "public": 1,
      "items_count": 15,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-04-23T09:00:45.336Z",
      "updated_at": "2019-04-23T09:00:45.000Z",
      "created_at": "2019-01-06T05:57:32.000Z",
      "namespace": "u46795/blog",
      "user": {
        "id": 155457,
        "type": "User",
        "login": "u46795",
        "name": "Nero",
        "description": "https://github.com/Ghostdar",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 5,
        "public_books_count": 5,
        "followers_count": 12,
        "following_count": 5,
        "created_at": "2018-08-04T03:45:56.000Z",
        "updated_at": "2019-04-30T15:08:36.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 155457,
    "creator": {
      "id": 155457,
      "type": "User",
      "login": "u46795",
      "name": "Nero",
      "description": "https://github.com/Ghostdar",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 5,
      "public_books_count": 5,
      "followers_count": 12,
      "following_count": 5,
      "created_at": "2018-08-04T03:45:56.000Z",
      "updated_at": "2019-04-30T15:08:36.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "date: 2017-08-15 17:06:02<br />categories: '前端'<br />tags: ['vue','wechat','前端']\n\n---\n\n\n小程序的秉承着 “体验极简化”、“用完即走” 的理念应运而生。许久之前，我就对小程序的个人版的推出满怀期待，想做点小玩意儿体验一下小程序，而后又忙于工作，没有付诸行动，如今在找工作期间得闲，花了4天，基于[Vue.js中文论坛]()提供的开发接口，开发了论坛的小程序版。<br /><!-- more -->\n<a name=\"e245b6b1\"></a>\n### 1. 主要功能：\n\n- 论坛帖子查看、收藏\n- 登陆发布新帖子\n- 评论和消息管理\n<a name=\"3fefb115\"></a>\n### 2. 目录结构\n```\n|——README.md          <= 项目介绍\n|——app.js             <= 主要逻辑文件\n|——app.json           <= 全局配置文件\n|——app.wxss           <= 公共样式文件 \n|——component          <= 组件库\n|  |——timeTeanslate   <= 时间格式转换组件\n|  |——wxParse         <= 富文本解析组件\n|  |——weui            <= weui样式库\n|——pages              <= 页面文件\n|  |——detail\n|  |——index           \n|  |——user\n|  |——api.js          <= 接口文件\n|  |——const.js        <= 常量定义文件\n|——static             <= 静态资源\n|  |——image\n```\n<a name=\"d610751b\"></a>\n### 3. 效果演示\n3.1 主页<br />![vue(2).png](https://cdn.nlark.com/yuque/0/2019/png/155457/1547265459399-7c9daac9-5265-4898-ba0e-960ac50f202f.png#align=left&display=inline&height=1327&name=vue%282%29.png&originHeight=1334&originWidth=750&size=244969&width=746)<br />3.2 文章详情<br />![vue(4).png](https://cdn.nlark.com/yuque/0/2019/png/155457/1547265471980-b3850dc9-d6b9-4ef2-bc67-602b8bf1b63a.png#align=left&display=inline&height=1327&name=vue%284%29.png&originHeight=1334&originWidth=750&size=154779&width=746)<br />3.3 登陆<br />![vue(1).png](https://cdn.nlark.com/yuque/0/2019/png/155457/1547265483018-9947b743-9f3e-4c05-9ea9-81e1a1b7d27e.png#align=left&display=inline&height=545&name=vue%281%29.png&originHeight=545&originWidth=320&size=7088&width=320)<br />3.4 个人中心<br />![vue(6).png](https://cdn.nlark.com/yuque/0/2019/png/155457/1547265510110-ca9be02e-1954-45f4-b49b-bcf024540bf2.png#align=left&display=inline&height=548&name=vue%286%29.png&originHeight=548&originWidth=319&size=12327&width=319)<br />3.5 发布文章<br />![vue(3).png](https://cdn.nlark.com/yuque/0/2019/png/155457/1547265526119-491b42c1-10c6-4fd4-8279-a8992f5c5c52.png#align=left&display=inline&height=1327&name=vue%283%29.png&originHeight=1334&originWidth=750&size=47954&width=746)<br />3.6 我的收藏<br />![vue(5).png](https://cdn.nlark.com/yuque/0/2019/png/155457/1547265549463-6798d862-a71c-495d-b5dd-649343ecc426.png#align=left&display=inline&height=1327&name=vue%285%29.png&originHeight=1334&originWidth=750&size=63813&width=746)<br />3.7 我的消息<br />![vue(7).png](https://cdn.nlark.com/yuque/0/2019/png/155457/1547265560772-4d23749b-b636-4caa-a39d-c6e0afc1937d.png#align=left&display=inline&height=547&name=vue%287%29.png&originHeight=547&originWidth=322&size=16121&width=322)\n<a name=\"76304aaf\"></a>\n### 4.总结\n<a name=\"0bd99f9a\"></a>\n#### 4.1 小程序的基本功能\n\n- 小程序的文件类型：\n```\njs ---------- 主要逻辑\njson -------- 项目配置文件，负责窗口颜色等等\nwxml ------- 类似HTML文件\nwxss ------- 类似CSS文件\n```\n\n- 创建一个页面：\n\n在page文件夹下创建一个页面的文件夹，里面新建4个必要的基本文件，然后再app.json中配置路由：\n```\n{\n  \"pages\":[\n    \"pages/index/index\",\n    \"pages/detail/detail\",\n    \"pages/user/user/user\",\n    \"pages/user/login/login\",\n    \"pages/user/message/message\",\n    \"pages/user/collect/collect\",\n    \"pages/user/newtopic/newtopic\"\n  ]\n}\n```\n\n- 发起一个API请求：\n```\nwx.request({\n      url: API.API.Post_mark_all,    // 请求url\n      method: 'POST',                // 请求方式\n      data: {\n        'accesstoken': token         // 参数\n      },\n      success: function (res) {\n        if (res.data.success) {\n          wx.showToast({\n            title: '标记成功',\n            icon: 'success',\n            duration: 1000\n          })\n          that.getMessage()\n        }else {\n          wx.showToast({\n            title: res.data.error_msg,\n            icon: 'success',\n            duration: 1000\n          })\n```\n\n- 本地缓存<br />\n由于没有类似Vuex的状态管理工具，一些公用的数据保存在本地缓存中，例如登陆的状态、accesstoken、用户的信息等。<br />\n操作本地缓存的方法有：\n```\n// 设置\nwx.setStorage()   //异步\nwx.setStorageSync() //同步\n// 获取\nwx.getStorage()   //异步\nwx.getStorageSync() //同步\n//清除\nwx.clearStorage()   //异步\nwx.clearStorageSync() //同步\n```\n\n- 页面的生命周期的方法：\n```\nonLoad   //页面加载\nonReady  //页面渲染完成\nonShow   //页面显示\nonHide   //页面隐藏\nonUnload  //页面卸载\n```\n<a name=\"0e0387f2\"></a>\n#### 4.2 未实现的功能\n由于时间原因,以下2个功能尚未完成:\n\n- 针对于某个特定用户的回复功能<br />\n- 点赞功能<br />\n<a name=\"ec036747\"></a>\n#### 4.3 有待优化的地方\n\n- 文章的富文本解析<br />\n- 小程序的状态管理<br />\n<a name=\"7ad31752\"></a>\n#### 4.4 个值得推荐的组件和库\n\n- wxParse 富文本解析组件\n- weui   微信官方UI库\n<a name=\"9415a826\"></a>\n#### 最后\n项目的github地址：[https://github.com/Ghostdar/wechat-weapp-vueForum]()<br />欢迎 `star!`\n",
    "body_draft": "",
    "body_html": "<p>date: 2017-08-15 17:06:02</p><p>categories: '前端'</p><p>tags: ['vue','wechat','前端']</p><hr /><p><br /></p><p>小程序的秉承着 “体验极简化”、“用完即走” 的理念应运而生。许久之前，我就对小程序的个人版的推出满怀期待，想做点小玩意儿体验一下小程序，而后又忙于工作，没有付诸行动，如今在找工作期间得闲，花了4天，基于<a target=\"_blank\">Vue.js中文论坛</a>提供的开发接口，开发了论坛的小程序版。</p><p>&lt;!-- more --&gt;</p><h3 id=\"e245b6b1\">1. 主要功能：</h3><ul><li>论坛帖子查看、收藏</li><li>登陆发布新帖子</li><li>评论和消息管理</li></ul><h3 id=\"3fefb115\">2. 目录结构</h3><pre><code>|——README.md          &lt;= 项目介绍\n|——app.js             &lt;= 主要逻辑文件\n|——app.json           &lt;= 全局配置文件\n|——app.wxss           &lt;= 公共样式文件 \n|——component          &lt;= 组件库\n|  |——timeTeanslate   &lt;= 时间格式转换组件\n|  |——wxParse         &lt;= 富文本解析组件\n|  |——weui            &lt;= weui样式库\n|——pages              &lt;= 页面文件\n|  |——detail\n|  |——index           \n|  |——user\n|  |——api.js          &lt;= 接口文件\n|  |——const.js        &lt;= 常量定义文件\n|——static             &lt;= 静态资源\n|  |——image</code></pre><h3 id=\"d610751b\">3. 效果演示</h3><p>3.1 主页</p><p><img alt=\"vue(2).png\" title=\"vue(2).png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/155457/1547265459399-7c9daac9-5265-4898-ba0e-960ac50f202f.png#align=left&amp;display=inline&amp;height=1327&amp;name=vue%282%29.png&amp;originHeight=1334&amp;originWidth=750&amp;size=244969&amp;width=746\" style=\"max-width: 600px; width: 746px;\" /></p><p>3.2 文章详情</p><p><img alt=\"vue(4).png\" title=\"vue(4).png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/155457/1547265471980-b3850dc9-d6b9-4ef2-bc67-602b8bf1b63a.png#align=left&amp;display=inline&amp;height=1327&amp;name=vue%284%29.png&amp;originHeight=1334&amp;originWidth=750&amp;size=154779&amp;width=746\" style=\"max-width: 600px; width: 746px;\" /></p><p>3.3 登陆</p><p><img alt=\"vue(1).png\" title=\"vue(1).png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/155457/1547265483018-9947b743-9f3e-4c05-9ea9-81e1a1b7d27e.png#align=left&amp;display=inline&amp;height=545&amp;name=vue%281%29.png&amp;originHeight=545&amp;originWidth=320&amp;size=7088&amp;width=320\" style=\"max-width: 600px; width: 320px;\" /></p><p>3.4 个人中心</p><p><img alt=\"vue(6).png\" title=\"vue(6).png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/155457/1547265510110-ca9be02e-1954-45f4-b49b-bcf024540bf2.png#align=left&amp;display=inline&amp;height=548&amp;name=vue%286%29.png&amp;originHeight=548&amp;originWidth=319&amp;size=12327&amp;width=319\" style=\"max-width: 600px; width: 319px;\" /></p><p>3.5 发布文章</p><p><img alt=\"vue(3).png\" title=\"vue(3).png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/155457/1547265526119-491b42c1-10c6-4fd4-8279-a8992f5c5c52.png#align=left&amp;display=inline&amp;height=1327&amp;name=vue%283%29.png&amp;originHeight=1334&amp;originWidth=750&amp;size=47954&amp;width=746\" style=\"max-width: 600px; width: 746px;\" /></p><p>3.6 我的收藏</p><p><img alt=\"vue(5).png\" title=\"vue(5).png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/155457/1547265549463-6798d862-a71c-495d-b5dd-649343ecc426.png#align=left&amp;display=inline&amp;height=1327&amp;name=vue%285%29.png&amp;originHeight=1334&amp;originWidth=750&amp;size=63813&amp;width=746\" style=\"max-width: 600px; width: 746px;\" /></p><p>3.7 我的消息</p><p><img alt=\"vue(7).png\" title=\"vue(7).png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/155457/1547265560772-4d23749b-b636-4caa-a39d-c6e0afc1937d.png#align=left&amp;display=inline&amp;height=547&amp;name=vue%287%29.png&amp;originHeight=547&amp;originWidth=322&amp;size=16121&amp;width=322\" style=\"max-width: 600px; width: 322px;\" /></p><h3 id=\"76304aaf\">4.总结</h3><h4 id=\"0bd99f9a\">4.1 小程序的基本功能</h4><ul><li>小程序的文件类型：</li></ul><pre><code>js ---------- 主要逻辑\njson -------- 项目配置文件，负责窗口颜色等等\nwxml ------- 类似HTML文件\nwxss ------- 类似CSS文件</code></pre><ul><li>创建一个页面：</li></ul><p>在page文件夹下创建一个页面的文件夹，里面新建4个必要的基本文件，然后再app.json中配置路由：</p><pre><code>{\n  &quot;pages&quot;:[\n    &quot;pages/index/index&quot;,\n    &quot;pages/detail/detail&quot;,\n    &quot;pages/user/user/user&quot;,\n    &quot;pages/user/login/login&quot;,\n    &quot;pages/user/message/message&quot;,\n    &quot;pages/user/collect/collect&quot;,\n    &quot;pages/user/newtopic/newtopic&quot;\n  ]\n}</code></pre><ul><li>发起一个API请求：</li></ul><pre><code>wx.request({\n      url: API.API.Post_mark_all,    // 请求url\n      method: 'POST',                // 请求方式\n      data: {\n        'accesstoken': token         // 参数\n      },\n      success: function (res) {\n        if (res.data.success) {\n          wx.showToast({\n            title: '标记成功',\n            icon: 'success',\n            duration: 1000\n          })\n          that.getMessage()\n        }else {\n          wx.showToast({\n            title: res.data.error_msg,\n            icon: 'success',\n            duration: 1000\n          })</code></pre><ul><li>本地缓存<br />\n由于没有类似Vuex的状态管理工具，一些公用的数据保存在本地缓存中，例如登陆的状态、accesstoken、用户的信息等。<br />\n操作本地缓存的方法有：</li></ul><pre><code>// 设置\nwx.setStorage()   //异步\nwx.setStorageSync() //同步\n// 获取\nwx.getStorage()   //异步\nwx.getStorageSync() //同步\n//清除\nwx.clearStorage()   //异步\nwx.clearStorageSync() //同步</code></pre><ul><li>页面的生命周期的方法：</li></ul><pre><code>onLoad   //页面加载\nonReady  //页面渲染完成\nonShow   //页面显示\nonHide   //页面隐藏\nonUnload  //页面卸载</code></pre><h4 id=\"0e0387f2\">4.2 未实现的功能</h4><p>由于时间原因,以下2个功能尚未完成:</p><ul><li>针对于某个特定用户的回复功能<br /></li><li>点赞功能<br /></li></ul><h4 id=\"ec036747\">4.3 有待优化的地方</h4><ul><li>文章的富文本解析<br /></li><li>小程序的状态管理<br /></li></ul><h4 id=\"7ad31752\">4.4 个值得推荐的组件和库</h4><ul><li>wxParse 富文本解析组件</li><li>weui   微信官方UI库</li></ul><h4 id=\"9415a826\">最后</h4><p>项目的github地址：<a target=\"_blank\">https://github.com/Ghostdar/wechat-weapp-vueForum</a></p><p>欢迎 <code>star!</code></p>",
    "body_lake": "<!doctype lake><p><cursor />date: 2017-08-15 17:06:02</p><p>categories: '前端'</p><p>tags: ['vue','wechat','前端']</p><card type=\"block\" name=\"hr\"></card><p><br /></p><p>小程序的秉承着 “体验极简化”、“用完即走” 的理念应运而生。许久之前，我就对小程序的个人版的推出满怀期待，想做点小玩意儿体验一下小程序，而后又忙于工作，没有付诸行动，如今在找工作期间得闲，花了4天，基于<a href=\"%22https://vue-js.com/%22\" target=\"_blank\">Vue.js中文论坛</a>提供的开发接口，开发了论坛的小程序版。</p><p>&lt;!-- more --&gt;</p><h3 id=\"e245b6b1\">1. 主要功能：</h3><ul><li>论坛帖子查看、收藏</li><li>登陆发布新帖子</li><li>评论和消息管理</li></ul><h3 id=\"3fefb115\">2. 目录结构</h3><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22plain%22%2C%22code%22%3A%22%7C%E2%80%94%E2%80%94README.md%20%20%20%20%20%20%20%20%20%20%3C%3D%20%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D%5Cn%7C%E2%80%94%E2%80%94app.js%20%20%20%20%20%20%20%20%20%20%20%20%20%3C%3D%20%E4%B8%BB%E8%A6%81%E9%80%BB%E8%BE%91%E6%96%87%E4%BB%B6%5Cn%7C%E2%80%94%E2%80%94app.json%20%20%20%20%20%20%20%20%20%20%20%3C%3D%20%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%5Cn%7C%E2%80%94%E2%80%94app.wxss%20%20%20%20%20%20%20%20%20%20%20%3C%3D%20%E5%85%AC%E5%85%B1%E6%A0%B7%E5%BC%8F%E6%96%87%E4%BB%B6%20%5Cn%7C%E2%80%94%E2%80%94component%20%20%20%20%20%20%20%20%20%20%3C%3D%20%E7%BB%84%E4%BB%B6%E5%BA%93%5Cn%7C%20%20%7C%E2%80%94%E2%80%94timeTeanslate%20%20%20%3C%3D%20%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2%E7%BB%84%E4%BB%B6%5Cn%7C%20%20%7C%E2%80%94%E2%80%94wxParse%20%20%20%20%20%20%20%20%20%3C%3D%20%E5%AF%8C%E6%96%87%E6%9C%AC%E8%A7%A3%E6%9E%90%E7%BB%84%E4%BB%B6%5Cn%7C%20%20%7C%E2%80%94%E2%80%94weui%20%20%20%20%20%20%20%20%20%20%20%20%3C%3D%20weui%E6%A0%B7%E5%BC%8F%E5%BA%93%5Cn%7C%E2%80%94%E2%80%94pages%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3C%3D%20%E9%A1%B5%E9%9D%A2%E6%96%87%E4%BB%B6%5Cn%7C%20%20%7C%E2%80%94%E2%80%94detail%5Cn%7C%20%20%7C%E2%80%94%E2%80%94index%20%20%20%20%20%20%20%20%20%20%20%5Cn%7C%20%20%7C%E2%80%94%E2%80%94user%5Cn%7C%20%20%7C%E2%80%94%E2%80%94api.js%20%20%20%20%20%20%20%20%20%20%3C%3D%20%E6%8E%A5%E5%8F%A3%E6%96%87%E4%BB%B6%5Cn%7C%20%20%7C%E2%80%94%E2%80%94const.js%20%20%20%20%20%20%20%20%3C%3D%20%E5%B8%B8%E9%87%8F%E5%AE%9A%E4%B9%89%E6%96%87%E4%BB%B6%5Cn%7C%E2%80%94%E2%80%94static%20%20%20%20%20%20%20%20%20%20%20%20%20%3C%3D%20%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%5Cn%7C%20%20%7C%E2%80%94%E2%80%94image%22%7D\"></card><h3 id=\"d610751b\">3. 效果演示</h3><p>3.1 主页</p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F155457%2F1547265459399-7c9daac9-5265-4898-ba0e-960ac50f202f.png%22%2C%22originWidth%22%3A750%2C%22originHeight%22%3A1334%2C%22name%22%3A%22vue(2).png%22%2C%22size%22%3A244969%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22width%22%3A746%2C%22height%22%3A1327%7D\"></card></p><p>3.2 文章详情</p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F155457%2F1547265471980-b3850dc9-d6b9-4ef2-bc67-602b8bf1b63a.png%22%2C%22originWidth%22%3A750%2C%22originHeight%22%3A1334%2C%22name%22%3A%22vue(4).png%22%2C%22size%22%3A154779%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22width%22%3A746%2C%22height%22%3A1327%7D\"></card></p><p>3.3 登陆</p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F155457%2F1547265483018-9947b743-9f3e-4c05-9ea9-81e1a1b7d27e.png%22%2C%22originWidth%22%3A320%2C%22originHeight%22%3A545%2C%22name%22%3A%22vue(1).png%22%2C%22size%22%3A7088%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22width%22%3A320%2C%22height%22%3A545%7D\"></card></p><p>3.4 个人中心</p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F155457%2F1547265510110-ca9be02e-1954-45f4-b49b-bcf024540bf2.png%22%2C%22originWidth%22%3A319%2C%22originHeight%22%3A548%2C%22name%22%3A%22vue(6).png%22%2C%22size%22%3A12327%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22width%22%3A319%2C%22height%22%3A548%7D\"></card></p><p>3.5 发布文章</p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F155457%2F1547265526119-491b42c1-10c6-4fd4-8279-a8992f5c5c52.png%22%2C%22originWidth%22%3A750%2C%22originHeight%22%3A1334%2C%22name%22%3A%22vue(3).png%22%2C%22size%22%3A47954%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22width%22%3A746%2C%22height%22%3A1327%7D\"></card></p><p>3.6 我的收藏</p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F155457%2F1547265549463-6798d862-a71c-495d-b5dd-649343ecc426.png%22%2C%22originWidth%22%3A750%2C%22originHeight%22%3A1334%2C%22name%22%3A%22vue(5).png%22%2C%22size%22%3A63813%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22width%22%3A746%2C%22height%22%3A1327%7D\"></card></p><p>3.7 我的消息</p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F155457%2F1547265560772-4d23749b-b636-4caa-a39d-c6e0afc1937d.png%22%2C%22originWidth%22%3A322%2C%22originHeight%22%3A547%2C%22name%22%3A%22vue(7).png%22%2C%22size%22%3A16121%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22width%22%3A322%2C%22height%22%3A547%7D\"></card></p><h3 id=\"76304aaf\">4.总结</h3><h4 id=\"0bd99f9a\">4.1 小程序的基本功能</h4><ul><li>小程序的文件类型：</li></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22plain%22%2C%22code%22%3A%22js%20----------%20%E4%B8%BB%E8%A6%81%E9%80%BB%E8%BE%91%5Cnjson%20--------%20%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%8C%E8%B4%9F%E8%B4%A3%E7%AA%97%E5%8F%A3%E9%A2%9C%E8%89%B2%E7%AD%89%E7%AD%89%5Cnwxml%20-------%20%E7%B1%BB%E4%BC%BCHTML%E6%96%87%E4%BB%B6%5Cnwxss%20-------%20%E7%B1%BB%E4%BC%BCCSS%E6%96%87%E4%BB%B6%22%7D\"></card><ul><li>创建一个页面：</li></ul><p>在page文件夹下创建一个页面的文件夹，里面新建4个必要的基本文件，然后再app.json中配置路由：</p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22plain%22%2C%22code%22%3A%22%7B%5Cn%20%20%5C%22pages%5C%22%3A%5B%5Cn%20%20%20%20%5C%22pages%2Findex%2Findex%5C%22%2C%5Cn%20%20%20%20%5C%22pages%2Fdetail%2Fdetail%5C%22%2C%5Cn%20%20%20%20%5C%22pages%2Fuser%2Fuser%2Fuser%5C%22%2C%5Cn%20%20%20%20%5C%22pages%2Fuser%2Flogin%2Flogin%5C%22%2C%5Cn%20%20%20%20%5C%22pages%2Fuser%2Fmessage%2Fmessage%5C%22%2C%5Cn%20%20%20%20%5C%22pages%2Fuser%2Fcollect%2Fcollect%5C%22%2C%5Cn%20%20%20%20%5C%22pages%2Fuser%2Fnewtopic%2Fnewtopic%5C%22%5Cn%20%20%5D%5Cn%7D%22%7D\"></card><ul><li>发起一个API请求：</li></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22plain%22%2C%22code%22%3A%22wx.request(%7B%5Cn%20%20%20%20%20%20url%3A%20API.API.Post_mark_all%2C%20%20%20%20%2F%2F%20%E8%AF%B7%E6%B1%82url%5Cn%20%20%20%20%20%20method%3A%20'POST'%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%5Cn%20%20%20%20%20%20data%3A%20%7B%5Cn%20%20%20%20%20%20%20%20'accesstoken'%3A%20token%20%20%20%20%20%20%20%20%20%2F%2F%20%E5%8F%82%E6%95%B0%5Cn%20%20%20%20%20%20%7D%2C%5Cn%20%20%20%20%20%20success%3A%20function%20(res)%20%7B%5Cn%20%20%20%20%20%20%20%20if%20(res.data.success)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20wx.showToast(%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20title%3A%20'%E6%A0%87%E8%AE%B0%E6%88%90%E5%8A%9F'%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20icon%3A%20'success'%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20duration%3A%201000%5Cn%20%20%20%20%20%20%20%20%20%20%7D)%5Cn%20%20%20%20%20%20%20%20%20%20that.getMessage()%5Cn%20%20%20%20%20%20%20%20%7Delse%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20wx.showToast(%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20title%3A%20res.data.error_msg%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20icon%3A%20'success'%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20duration%3A%201000%5Cn%20%20%20%20%20%20%20%20%20%20%7D)%22%7D\"></card><ul><li>本地缓存<br />\n由于没有类似Vuex的状态管理工具，一些公用的数据保存在本地缓存中，例如登陆的状态、accesstoken、用户的信息等。<br />\n操作本地缓存的方法有：</li></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22plain%22%2C%22code%22%3A%22%2F%2F%20%E8%AE%BE%E7%BD%AE%5Cnwx.setStorage()%20%20%20%2F%2F%E5%BC%82%E6%AD%A5%5Cnwx.setStorageSync()%20%2F%2F%E5%90%8C%E6%AD%A5%5Cn%2F%2F%20%E8%8E%B7%E5%8F%96%5Cnwx.getStorage()%20%20%20%2F%2F%E5%BC%82%E6%AD%A5%5Cnwx.getStorageSync()%20%2F%2F%E5%90%8C%E6%AD%A5%5Cn%2F%2F%E6%B8%85%E9%99%A4%5Cnwx.clearStorage()%20%20%20%2F%2F%E5%BC%82%E6%AD%A5%5Cnwx.clearStorageSync()%20%2F%2F%E5%90%8C%E6%AD%A5%22%7D\"></card><ul><li>页面的生命周期的方法：</li></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22plain%22%2C%22code%22%3A%22onLoad%20%20%20%2F%2F%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%5CnonReady%20%20%2F%2F%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E5%AE%8C%E6%88%90%5CnonShow%20%20%20%2F%2F%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%5CnonHide%20%20%20%2F%2F%E9%A1%B5%E9%9D%A2%E9%9A%90%E8%97%8F%5CnonUnload%20%20%2F%2F%E9%A1%B5%E9%9D%A2%E5%8D%B8%E8%BD%BD%22%7D\"></card><h4 id=\"0e0387f2\">4.2 未实现的功能</h4><p>由于时间原因,以下2个功能尚未完成:</p><ul><li>针对于某个特定用户的回复功能<br /></li><li>点赞功能<br /></li></ul><h4 id=\"ec036747\">4.3 有待优化的地方</h4><ul><li>文章的富文本解析<br /></li><li>小程序的状态管理<br /></li></ul><h4 id=\"7ad31752\">4.4 个值得推荐的组件和库</h4><ul><li>wxParse 富文本解析组件</li><li>weui   微信官方UI库</li></ul><h4 id=\"9415a826\">最后</h4><p>项目的github地址：<a href=\"%22https://github.com/Ghostdar/wechat-weapp-vueForum%22\" target=\"_blank\">https://github.com/Ghostdar/wechat-weapp-vueForum</a></p><p>欢迎 <code>star!</code></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-01-12T04:12:40.000Z",
    "deleted_at": null,
    "created_at": "2019-01-12T03:56:20.000Z",
    "updated_at": "2019-01-12T04:12:40.000Z",
    "published_at": "2019-01-12T04:12:40.000Z",
    "first_published_at": "2019-01-12T03:59:31.000Z",
    "word_count": 749,
    "cover": null,
    "description": "date: 2017-08-15 17:06:02categories: '前端'tags: ['vue','wechat','前端']小程序的秉承着 “体验极简化”、“用完即走” 的理念应运而生。许久之前，我就对小程序的个人版的推出满怀期待，想做点小玩意儿体验一下小程序，而后又忙于工作，没有...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1138559,
    "slug": "oi9l8t",
    "title": "为什么开始写博客",
    "book_id": 199054,
    "book": {
      "id": 199054,
      "type": "Book",
      "slug": "blog",
      "name": "博客",
      "user_id": 155457,
      "description": "前端技术博客存档",
      "creator_id": 155457,
      "public": 1,
      "items_count": 15,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-04-23T09:00:45.336Z",
      "updated_at": "2019-04-23T09:00:45.000Z",
      "created_at": "2019-01-06T05:57:32.000Z",
      "namespace": "u46795/blog",
      "user": {
        "id": 155457,
        "type": "User",
        "login": "u46795",
        "name": "Nero",
        "description": "https://github.com/Ghostdar",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 5,
        "public_books_count": 5,
        "followers_count": 12,
        "following_count": 5,
        "created_at": "2018-08-04T03:45:56.000Z",
        "updated_at": "2019-04-30T15:08:36.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 155457,
    "creator": {
      "id": 155457,
      "type": "User",
      "login": "u46795",
      "name": "Nero",
      "description": "https://github.com/Ghostdar",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 5,
      "public_books_count": 5,
      "followers_count": 12,
      "following_count": 5,
      "created_at": "2018-08-04T03:45:56.000Z",
      "updated_at": "2019-04-30T15:08:36.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "date: 2018-03-11 23:21:54<br />categories: '随笔'<br />tags: '随笔'\n\n---\n\n每一行代码，都是美丽的诗句。写代码快3年了，从小白一路走来，学的东西多，写的却很少。从后端再到现在的前端，有时候想缅怀一下过去，那些好的和不好的，却发现时间不仅模糊了记忆，还让人忘记了初心。所以，我想记录写过的代码，学过的东西。人嘛，总要留下点痕迹，不是么..<br /><!-- more -->\n<a name=\"ddcb5f7d\"></a>\n##### 那点事儿\n\n写博客嘛，总要先选个地儿，考虑过 诸如 博客园 啦、CSDN 啦、segmentfault 啦 、简书 等等。但都不太喜欢，最终还是选择了 Hexo + github 来建立自己的博客。建站教程嘛，google一下很多的啦，就不啰嗦了~ 捣鼓了一个周末，终于把博客改造好了。很开心，这里还是记录一下DIY的那些事儿：\n\n<a name=\"84cd8bb0\"></a>\n##### 换个主题\n\n网上有非常多好看的Hexo主题，再三纠结之后，选了一个简单干净又不失优雅的 [Next](http://theme-next.iissnan.com/theme-settings.html)，首先当然是把主题下载下来啦，官网上的地址是:\n\n```\n$ cd your-hexo-site\n$ git clone https://github.com/iissnan/hexo-theme-next themes/next\n```\n\n但其实此主题的最新版放在了这里：\n\n```\n$ git clone https://github.com/theme-next/hexo-theme-next themes/next\n```\n\n下载下来后只需在更改博客的配置文件`_config.yml`中:\n\n```\ntheme: next\n```\n\n然后运行 `hexo s -p 4444`  就可以在浏览器中 访问 `localhost：4444` 看到博客啦~\n\n此外，next 是拥有题中题的主题（哈哈，好绕口~），有Muse、Mist、Pisces、Gemini 四种模式可以选择，在next文件夹下的`_config.yml` 中修改：\n\n```\nscheme: Mist\n```\n\n就可以看到mist主题下的博客啦：<br />\n![博客.png](https://cdn.nlark.com/yuque/0/2019/png/155457/1547265206903-0b25942f-f708-44d8-8f31-d63aae28b96c.png#align=left&display=inline&height=318&name=%E5%8D%9A%E5%AE%A2.png&originHeight=576&originWidth=1353&size=65593&width=746)\n\n<a name=\"912b0e0a\"></a>\n##### 右上角加个 github 小图标\n\n在[这里](https://github.com/blog/273-github-ribbons)选择一个喜欢的样式，然后复制代码到`next\\layout\\_layout.swig`文件找到:\n\n```\n<div class=\"headband\"></div>\n//复制的代码放在这里,将链接地址改成自己github地址\n```\n\n<a name=\"3897db13\"></a>\n##### 右侧小图标\n\n先在 [图标库](https://fontawesome.com/icons?d=gallery) 里选择对应的图标，然后再`_config.yml` 中修改:\n\n```\nsocial:\n  GitHub: https://github.com/Ghostdar || github\n  E-Mail: mailto:848760247@qq.com || envelope\n  SegmentFault:　https://segmentfault.com/u/ghostdar　||　SegmentFault \nsocial_icons:\n  enable: true\n  icons_only: false\n  transition: false\n  \n  GitHub: github\n  E-Mail: envelope\n  SegmentFault:　SegmentFault \n  \n  exturl: false\n```\n\n<a name=\"74329fc2\"></a>\n##### 添加访客统计代码：\n\n打开 `\\themes\\next\\layout\\_partials\\footer.swig` 文件，在copyright前加上：\n\n```\n<script async src=\"https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"></script>\n```\n\n然后在合适的地方加上显示统计的代码：\n\n```\n<div class=\"powered-by\">\n<i class=\"fa fa-user-md\"></i><span id=\"busuanzi_container_site_uv\">\n  本站访客数:<span id=\"busuanzi_value_site_uv\"></span>\n</span>|\n<i class=\"fa fa-eye\"></i><span id=\"busuanzi_container_site_pv\">\n    本站总访问量<span id=\"busuanzi_value_site_pv\"></span>次\n</span>\n</div>\n```\n\n<a name=\"0c50f3ac\"></a>\n##### 为博客添加评论系统\n\n由于网易云跟帖已下线，我使用的是[来必利](https://livere.com/)，<br />\n注册完成后，选择安装city版本 ，填写一些资料后，就能拿到安装代码，复制其中data-uid 里的内容，然后在主题配置文件下修：\n\n```\nlivere_uid：your uid\n```\n\n大功告成！！\n\n<a name=\"b2199175\"></a>\n##### 使用专属域名\n\n首先，使用cmd  ping github 地址:\n\n![cmd.png](https://cdn.nlark.com/yuque/0/2019/png/155457/1547265245752-bfdceb80-c90c-4874-a731-b1f8ba6e96b0.png#align=left&display=inline&height=340&name=cmd.png&originHeight=340&originWidth=734&size=15962&width=734)\n\n然后添加域名解析到此IP：\n\n![域名解析.png](https://cdn.nlark.com/yuque/0/2019/png/155457/1547265260591-d8b29f7e-875c-4551-9e35-8e472fcccff6.png#align=left&display=inline&height=192&name=%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90.png&originHeight=257&originWidth=1001&size=37643&width=746)\n\n最后，在github 上设置：\n\n![github设置.png](https://cdn.nlark.com/yuque/0/2019/png/155457/1547265313249-439a694d-1d70-4f6e-8936-dc487562b274.png#align=left&display=inline&height=426&name=github%E8%AE%BE%E7%BD%AE.png&originHeight=507&originWidth=887&size=46198&width=746)\n\n然后就可以愉快的使用自己的域名访问啦~\n\n<a name=\"2a302fa5\"></a>\n##### 参考文章\n\n- [hexo的next主题个性化配置教程](http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html)\n- [hexo博客优化之实现来必力评论功能](http://blog.csdn.net/qwerty200696/article/details/78836421)\n",
    "body_draft": "",
    "body_html": "<p>date: 2018-03-11 23:21:54</p><p><span>categories</span>: '随笔'</p><p>tags: '随笔'</p><hr /><p>每一行代码，都是美丽的诗句。写代码快3年了，从小白一路走来，学的东西多，写的却很少。从后端再到现在的前端，有时候想缅怀一下过去，那些好的和不好的，却发现时间不仅模糊了记忆，还让人忘记了初心。所以，我想记录写过的代码，学过的东西。人嘛，总要留下点痕迹，不是么..</p><p>&lt;!-- more --&gt;</p><h5 id=\"ddcb5f7d\">那点事儿<span style=\"color: #595959; background-color: #FAFAFA;\"></span><span style=\"color: #595959; background-color: #FAFAFA;\"></span></h5><p><br /></p><p>写博客嘛，总要先选个地儿，考虑过 诸如 博客园 啦、CSDN 啦、segmentfault 啦 、简书 等等。但都不太喜欢，最终还是选择了 Hexo + github 来建立自己的博客。建站教程嘛，google一下很多的啦，就不啰嗦了~ 捣鼓了一个周末，终于把博客改造好了。很开心，这里还是记录一下DIY的那些事儿：</p><p><br /></p><h5 id=\"84cd8bb0\">换个主题</h5><p><br /></p><p>网上有非常多好看的Hexo主题，再三纠结之后，选了一个简单干净又不失优雅的 <a href=\"http://theme-next.iissnan.com/theme-settings.html\" target=\"_blank\">Next</a>，首先当然是把主题下载下来啦，官网上的地址是:</p><p><br /></p><pre><code>$ cd your-hexo-site\n$ git clone https://github.com/iissnan/hexo-theme-next themes/next</code></pre><p><br /></p><p>但其实此主题的最新版放在了这里：</p><p><br /></p><pre><code>$ git clone https://github.com/theme-next/hexo-theme-next themes/next</code></pre><p><br /></p><p>下载下来后只需在更改博客的配置文件<code>_config.yml</code>中:</p><p><br /></p><pre><code>theme: next</code></pre><p><br /></p><p>然后运行 <code>hexo s -p 4444</code>  就可以在浏览器中 访问 <code>localhost：4444</code> 看到博客啦~</p><p><br /></p><p>此外，next 是拥有题中题的主题（哈哈，好绕口~），有Muse、Mist、Pisces、Gemini 四种模式可以选择，在next文件夹下的<code>_config.yml</code> 中修改：</p><p><br /></p><pre><code>scheme: Mist</code></pre><p><br /></p><p>就可以看到mist主题下的博客啦：<br />\n<span style=\"color: #595959; background-color: #FAFAFA;\"></span><img alt=\"博客.png\" title=\"博客.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/155457/1547265206903-0b25942f-f708-44d8-8f31-d63aae28b96c.png#align=left&amp;display=inline&amp;height=318&amp;name=%E5%8D%9A%E5%AE%A2.png&amp;originHeight=576&amp;originWidth=1353&amp;size=65593&amp;width=746\" style=\"max-width: 600px; width: 746px;\" /><span style=\"color: #595959; background-color: #FAFAFA;\"></span></p><p><br /></p><h5 id=\"912b0e0a\">右上角加个 github 小图标</h5><p><br /></p><p>在<a href=\"https://github.com/blog/273-github-ribbons\" target=\"_blank\">这里</a>选择一个喜欢的样式，然后复制代码到<code>next\\layout\\_layout.swig</code>文件找到:</p><p><br /></p><pre><code>&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;\n//复制的代码放在这里,将链接地址改成自己github地址</code></pre><p><br /></p><h5 id=\"3897db13\">右侧小图标</h5><p><br /></p><p>先在 <a href=\"https://fontawesome.com/icons?d=gallery\" target=\"_blank\">图标库</a> 里选择对应的图标，然后再<code>_config.yml</code> 中修改:</p><p><br /></p><pre><code>social:\n  GitHub: https://github.com/Ghostdar || github\n  E-Mail: mailto:848760247@qq.com || envelope\n  SegmentFault:　https://segmentfault.com/u/ghostdar　||　SegmentFault \nsocial_icons:\n  enable: true\n  icons_only: false\n  transition: false\n  \n  GitHub: github\n  E-Mail: envelope\n  SegmentFault:　SegmentFault \n  \n  exturl: false</code></pre><p><br /></p><h5 id=\"74329fc2\">添加访客统计代码：</h5><p><br /></p><p>打开 <code>\\themes\\next\\layout\\_partials\\footer.swig</code> 文件，在copyright前加上：</p><p><br /></p><pre><code>&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</code></pre><p><br /></p><p>然后在合适的地方加上显示统计的代码：</p><p><br /></p><pre><code>&lt;div class=&quot;powered-by&quot;&gt;\n&lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;\n  本站访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;\n&lt;/span&gt;|\n&lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;\n    本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次\n&lt;/span&gt;\n&lt;/div&gt;</code></pre><p><br /></p><h5 id=\"0c50f3ac\">为博客添加评论系统</h5><p><br /></p><p>由于网易云跟帖已下线，我使用的是<a href=\"https://livere.com/\" target=\"_blank\">来必利</a>，<br />\n注册完成后，选择安装city版本 ，填写一些资料后，就能拿到安装代码，复制其中data-uid 里的内容，然后在主题配置文件下修：</p><p><br /></p><pre><code>livere_uid：your uid</code></pre><p><br /></p><p>大功告成！！</p><p><br /></p><h5 id=\"b2199175\">使用专属域名</h5><p><br /></p><p>首先，使用cmd  ping github 地址:</p><p><br /></p><p><img alt=\"cmd.png\" title=\"cmd.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/155457/1547265245752-bfdceb80-c90c-4874-a731-b1f8ba6e96b0.png#align=left&amp;display=inline&amp;height=340&amp;name=cmd.png&amp;originHeight=340&amp;originWidth=734&amp;size=15962&amp;width=734\" style=\"max-width: 600px; width: 734px;\" /></p><p><br /></p><p>然后添加域名解析到此IP：</p><p><br /></p><p><img alt=\"域名解析.png\" title=\"域名解析.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/155457/1547265260591-d8b29f7e-875c-4551-9e35-8e472fcccff6.png#align=left&amp;display=inline&amp;height=192&amp;name=%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90.png&amp;originHeight=257&amp;originWidth=1001&amp;size=37643&amp;width=746\" style=\"max-width: 600px; width: 746px;\" /></p><p><br /></p><p>最后，在github 上设置：<br /></p><p><img alt=\"github设置.png\" title=\"github设置.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/155457/1547265313249-439a694d-1d70-4f6e-8936-dc487562b274.png#align=left&amp;display=inline&amp;height=426&amp;name=github%E8%AE%BE%E7%BD%AE.png&amp;originHeight=507&amp;originWidth=887&amp;size=46198&amp;width=746\" style=\"max-width: 600px; width: 746px;\" /></p><p><br /></p><p>然后就可以愉快的使用自己的域名访问啦~</p><p><br /></p><h5 id=\"2a302fa5\">参考文章</h5><p><br /></p><ul><li><a href=\"http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html\" target=\"_blank\">hexo的next主题个性化配置教程</a></li></ul><ul><li><a href=\"http://blog.csdn.net/qwerty200696/article/details/78836421\" target=\"_blank\">hexo博客优化之实现来必力评论功能</a></li></ul>",
    "body_lake": "<!doctype lake><p>date: 2018-03-11 23:21:54</p><p><span>categories<cursor /></span>: '随笔'</p><p>tags: '随笔'</p><card type=\"block\" name=\"hr\"></card><p>每一行代码，都是美丽的诗句。写代码快3年了，从小白一路走来，学的东西多，写的却很少。从后端再到现在的前端，有时候想缅怀一下过去，那些好的和不好的，却发现时间不仅模糊了记忆，还让人忘记了初心。所以，我想记录写过的代码，学过的东西。人嘛，总要留下点痕迹，不是么..</p><p>&lt;!-- more --&gt;</p><h5 id=\"ddcb5f7d\">那点事儿<span style=\"color: #595959; background-color: #FAFAFA;\"></span><span style=\"color: #595959; background-color: #FAFAFA;\"></span></h5><p><br /></p><p>写博客嘛，总要先选个地儿，考虑过 诸如 博客园 啦、CSDN 啦、segmentfault 啦 、简书 等等。但都不太喜欢，最终还是选择了 Hexo + github 来建立自己的博客。建站教程嘛，google一下很多的啦，就不啰嗦了~ 捣鼓了一个周末，终于把博客改造好了。很开心，这里还是记录一下DIY的那些事儿：</p><p><br /></p><h5 id=\"84cd8bb0\">换个主题</h5><p><br /></p><p>网上有非常多好看的Hexo主题，再三纠结之后，选了一个简单干净又不失优雅的 <a href=\"http://theme-next.iissnan.com/theme-settings.html\" target=\"_blank\">Next</a>，首先当然是把主题下载下来啦，官网上的地址是:</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22code%22%3A%22%24%20cd%20your-hexo-site%5Cn%24%20git%20clone%20https%3A%2F%2Fgithub.com%2Fiissnan%2Fhexo-theme-next%20themes%2Fnext%22%7D\"></card><p><br /></p><p>但其实此主题的最新版放在了这里：</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22code%22%3A%22%24%20git%20clone%20https%3A%2F%2Fgithub.com%2Ftheme-next%2Fhexo-theme-next%20themes%2Fnext%22%7D\"></card><p><br /></p><p>下载下来后只需在更改博客的配置文件<code>_config.yml</code>中:</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22code%22%3A%22theme%3A%20next%22%7D\"></card><p><br /></p><p>然后运行 <code>hexo s -p 4444</code>  就可以在浏览器中 访问 <code>localhost：4444</code> 看到博客啦~</p><p><br /></p><p>此外，next 是拥有题中题的主题（哈哈，好绕口~），有Muse、Mist、Pisces、Gemini 四种模式可以选择，在next文件夹下的<code>_config.yml</code> 中修改：</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22code%22%3A%22scheme%3A%20Mist%22%7D\"></card><p><br /></p><p>就可以看到mist主题下的博客啦：<br />\n<span style=\"color: #595959; background-color: #FAFAFA;\"></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F155457%2F1547265206903-0b25942f-f708-44d8-8f31-d63aae28b96c.png%22%2C%22originWidth%22%3A1353%2C%22originHeight%22%3A576%2C%22name%22%3A%22%E5%8D%9A%E5%AE%A2.png%22%2C%22size%22%3A65593%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22width%22%3A746%2C%22height%22%3A318%7D\"></card><span style=\"color: #595959; background-color: #FAFAFA;\"></span></p><p><br /></p><h5 id=\"912b0e0a\">右上角加个 github 小图标</h5><p><br /></p><p>在<a href=\"https://github.com/blog/273-github-ribbons\" target=\"_blank\">这里</a>选择一个喜欢的样式，然后复制代码到<code>next\\layout\\_layout.swig</code>文件找到:</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22code%22%3A%22%3Cdiv%20class%3D%5C%22headband%5C%22%3E%3C%2Fdiv%3E%5Cn%2F%2F%E5%A4%8D%E5%88%B6%E7%9A%84%E4%BB%A3%E7%A0%81%E6%94%BE%E5%9C%A8%E8%BF%99%E9%87%8C%2C%E5%B0%86%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80%E6%94%B9%E6%88%90%E8%87%AA%E5%B7%B1github%E5%9C%B0%E5%9D%80%22%7D\"></card><p><br /></p><h5 id=\"3897db13\">右侧小图标</h5><p><br /></p><p>先在 <a href=\"https://fontawesome.com/icons?d=gallery\" target=\"_blank\">图标库</a> 里选择对应的图标，然后再<code>_config.yml</code> 中修改:</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22code%22%3A%22social%3A%5Cn%20%20GitHub%3A%20https%3A%2F%2Fgithub.com%2FGhostdar%20%7C%7C%20github%5Cn%20%20E-Mail%3A%20mailto%3A848760247%40qq.com%20%7C%7C%20envelope%5Cn%20%20SegmentFault%3A%E3%80%80https%3A%2F%2Fsegmentfault.com%2Fu%2Fghostdar%E3%80%80%7C%7C%E3%80%80SegmentFault%20%5Cnsocial_icons%3A%5Cn%20%20enable%3A%20true%5Cn%20%20icons_only%3A%20false%5Cn%20%20transition%3A%20false%5Cn%20%20%5Cn%20%20GitHub%3A%20github%5Cn%20%20E-Mail%3A%20envelope%5Cn%20%20SegmentFault%3A%E3%80%80SegmentFault%20%5Cn%20%20%5Cn%20%20exturl%3A%20false%22%7D\"></card><p><br /></p><h5 id=\"74329fc2\">添加访客统计代码：</h5><p><br /></p><p>打开 <code>\\themes\\next\\layout\\_partials\\footer.swig</code> 文件，在copyright前加上：</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22code%22%3A%22%3Cscript%20async%20src%3D%5C%22https%3A%2F%2Fdn-lbstatics.qbox.me%2Fbusuanzi%2F2.3%2Fbusuanzi.pure.mini.js%5C%22%3E%3C%2Fscript%3E%22%7D\"></card><p><br /></p><p>然后在合适的地方加上显示统计的代码：</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22code%22%3A%22%3Cdiv%20class%3D%5C%22powered-by%5C%22%3E%5Cn%3Ci%20class%3D%5C%22fa%20fa-user-md%5C%22%3E%3C%2Fi%3E%3Cspan%20id%3D%5C%22busuanzi_container_site_uv%5C%22%3E%5Cn%20%20%E6%9C%AC%E7%AB%99%E8%AE%BF%E5%AE%A2%E6%95%B0%3A%3Cspan%20id%3D%5C%22busuanzi_value_site_uv%5C%22%3E%3C%2Fspan%3E%5Cn%3C%2Fspan%3E%7C%5Cn%3Ci%20class%3D%5C%22fa%20fa-eye%5C%22%3E%3C%2Fi%3E%3Cspan%20id%3D%5C%22busuanzi_container_site_pv%5C%22%3E%5Cn%20%20%20%20%E6%9C%AC%E7%AB%99%E6%80%BB%E8%AE%BF%E9%97%AE%E9%87%8F%3Cspan%20id%3D%5C%22busuanzi_value_site_pv%5C%22%3E%3C%2Fspan%3E%E6%AC%A1%5Cn%3C%2Fspan%3E%5Cn%3C%2Fdiv%3E%22%7D\"></card><p><br /></p><h5 id=\"0c50f3ac\">为博客添加评论系统</h5><p><br /></p><p>由于网易云跟帖已下线，我使用的是<a href=\"https://livere.com/\" target=\"_blank\">来必利</a>，<br />\n注册完成后，选择安装city版本 ，填写一些资料后，就能拿到安装代码，复制其中data-uid 里的内容，然后在主题配置文件下修：</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22code%22%3A%22livere_uid%EF%BC%9Ayour%20uid%22%7D\"></card><p><br /></p><p>大功告成！！</p><p><br /></p><h5 id=\"b2199175\">使用专属域名</h5><p><br /></p><p>首先，使用cmd  ping github 地址:</p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F155457%2F1547265245752-bfdceb80-c90c-4874-a731-b1f8ba6e96b0.png%22%2C%22originWidth%22%3A734%2C%22originHeight%22%3A340%2C%22name%22%3A%22cmd.png%22%2C%22size%22%3A15962%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22width%22%3A734%2C%22height%22%3A340%7D\"></card></p><p><br /></p><p>然后添加域名解析到此IP：</p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F155457%2F1547265260591-d8b29f7e-875c-4551-9e35-8e472fcccff6.png%22%2C%22originWidth%22%3A1001%2C%22originHeight%22%3A257%2C%22name%22%3A%22%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90.png%22%2C%22size%22%3A37643%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22width%22%3A746%2C%22height%22%3A192%7D\"></card></p><p><br /></p><p>最后，在github 上设置：<br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F155457%2F1547265313249-439a694d-1d70-4f6e-8936-dc487562b274.png%22%2C%22originWidth%22%3A887%2C%22originHeight%22%3A507%2C%22name%22%3A%22github%E8%AE%BE%E7%BD%AE.png%22%2C%22size%22%3A46198%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22width%22%3A746%2C%22height%22%3A426%7D\"></card></p><p><br /></p><p>然后就可以愉快的使用自己的域名访问啦~</p><p><br /></p><h5 id=\"2a302fa5\">参考文章</h5><p><br /></p><ul><li><a href=\"http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html\" target=\"_blank\">hexo的next主题个性化配置教程</a></li></ul><ul><li><a href=\"http://blog.csdn.net/qwerty200696/article/details/78836421\" target=\"_blank\">hexo博客优化之实现来必力评论功能</a></li></ul>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-01-12T04:12:21.000Z",
    "deleted_at": null,
    "created_at": "2019-01-12T03:52:18.000Z",
    "updated_at": "2019-01-12T04:12:21.000Z",
    "published_at": "2019-01-12T04:12:21.000Z",
    "first_published_at": "2019-01-12T03:55:23.000Z",
    "word_count": 899,
    "cover": null,
    "description": "date: 2018-03-11 23:21:54categories: '随笔'tags: '随笔'每一行代码，都是美丽的诗句。写代码快3年了，从小白一路走来，学的东西多，写的却很少。从后端再到现在的前端，有时候想缅怀一下过去，那些好的和不好的，却发现时间不仅模糊了记忆，还让人忘记了初心。所...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1138550,
    "slug": "dfgmbr",
    "title": "web安全之CSRF攻击",
    "book_id": 199054,
    "book": {
      "id": 199054,
      "type": "Book",
      "slug": "blog",
      "name": "博客",
      "user_id": 155457,
      "description": "前端技术博客存档",
      "creator_id": 155457,
      "public": 1,
      "items_count": 15,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-04-23T09:00:45.336Z",
      "updated_at": "2019-04-23T09:00:45.000Z",
      "created_at": "2019-01-06T05:57:32.000Z",
      "namespace": "u46795/blog",
      "user": {
        "id": 155457,
        "type": "User",
        "login": "u46795",
        "name": "Nero",
        "description": "https://github.com/Ghostdar",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 5,
        "public_books_count": 5,
        "followers_count": 12,
        "following_count": 5,
        "created_at": "2018-08-04T03:45:56.000Z",
        "updated_at": "2019-04-30T15:08:36.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 155457,
    "creator": {
      "id": 155457,
      "type": "User",
      "login": "u46795",
      "name": "Nero",
      "description": "https://github.com/Ghostdar",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 5,
      "public_books_count": 5,
      "followers_count": 12,
      "following_count": 5,
      "created_at": "2018-08-04T03:45:56.000Z",
      "updated_at": "2019-04-30T15:08:36.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "date: 2017-03-28 23:08:32<br />categories: '前端'<br />tags: ['web安全']\n\n---\n\nCSRF(Cross Site Request Forgery,跨站请求伪造)攻击是一种依赖web浏览器的、被混淆过的代理人攻击，通过伪装来自受信任用户的请求来利用受信任的网站，造成个人隐私泄露及财产安全。<br /><!-- more -->\n\n那么，CSRF攻击是怎样的流程呢？\n\n![CSRF攻击图解.png](https://cdn.nlark.com/yuque/0/2019/png/155457/1547264911153-67d7ef97-78a3-428a-b629-51ea80340304.png#align=left&display=inline&height=459&name=CSRF%E6%94%BB%E5%87%BB%E5%9B%BE%E8%A7%A3.png&originHeight=459&originWidth=726&size=17843&width=726)\n\n1. step1: 客户端向网站A发起了通信请求\n\n2. step2: 网站A验证通过，并建立了通信连接，在客户端保存了A的cookie.\n\n3. step3: 客户端在未关闭与A的连接的情况下访问了网站B.\n\n4. step4: 网站B含有恶意请求代码，要求向网站A发起请求.\n\n5. step5：客户端根据B发起的请求并携带已保存的网站A的cookie访问网站A.\n\n6. step6: 网站A验证cookie并处理了这个请求.\n\n\n于是，网站B就通过盗用保存在客户端的cookie，以客户端的身份来访问网站A，做一些诸如：发送信息，邮件，盗取账户，财产等违法操作。<br />\n\n由于我们现在使用的都是多窗口的浏览器，例如chorme、firefox、360浏览器等等。在带来方便的同时，也方便了CSRF的攻击，因为多窗口的浏览器都是单进程的，每个窗口的会话是共享的，所以会话信息很容易被利用。<br />\n\n那么，如何预防CSRF呢？其实防范CSRF的思想都是一致的，就是增加伪随机数(token)的验证。\n\n1. 通过 referer、token 或者 验证码 来检测用户提交.例如：\n  1. 在标签加入token：```\n<meta content=\"_csrf\" name=\"csrf-param\">\n<meta content=\"6eEHcEur-Q-CoC0eMc3GIRofusFMhD6fYr4Y\" name=\"csrf-token\">\n```\n\n  1. 在表单加入token:```\n<input type=\"hidden\" name=\"csrf_token\" value=\"<? echo $token;?>\">\n```\n\n  1. 请求操作要求输入验证码.(ps：这个一定程度上会影响用户体验)\n2. 尽量不要在页面的链接中暴露用户隐私信息.\n2. 尽量使用post进行表单提交\n2. 避免全站通用的cookie，严格设置cookie的域\n\n目前来说，做好以上几点，几乎能防范99%的CSRF攻击啦。哈哈~\n",
    "body_draft": "",
    "body_html": "<p>date: 2017-03-28 23:08:32</p><p>categories: '前端'</p><p>tags: ['web安全']</p><hr /><p>CSRF(Cross Site Request Forgery,跨站请求伪造)攻击是一种依赖web浏览器的、被混淆过的代理人攻击，通过伪装来自受信任用户的请求来利用受信任的网站，造成个人隐私泄露及财产安全。</p><p>&lt;!-- more --&gt;</p><p><br /></p><p>那么，CSRF攻击是怎样的流程呢？</p><p><br /></p><p><img alt=\"CSRF攻击图解.png\" title=\"CSRF攻击图解.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/155457/1547264911153-67d7ef97-78a3-428a-b629-51ea80340304.png#align=left&amp;display=inline&amp;height=459&amp;name=CSRF%E6%94%BB%E5%87%BB%E5%9B%BE%E8%A7%A3.png&amp;originHeight=459&amp;originWidth=726&amp;size=17843&amp;width=726\" style=\"max-width: 600px; width: 726px;\" /></p><p><br /></p><ol start=\"1\"><li><p>step1: 客户端向网站A发起了通信请求</p></li></ol><ol start=\"2\"><li><p>step2: 网站A验证通过，并建立了通信连接，在客户端保存了A的cookie.</p></li></ol><ol start=\"3\"><li><p>step3: 客户端在未关闭与A的连接的情况下访问了网站B.</p></li></ol><ol start=\"4\"><li><p>step4: 网站B含有恶意请求代码，要求向网站A发起请求.</p></li></ol><ol start=\"5\"><li><p>step5：客户端根据B发起的请求并携带已保存的网站A的cookie访问网站A.</p></li></ol><ol start=\"6\"><li><p>step6: 网站A验证cookie并处理了这个请求.</p></li></ol><p><br /></p><p>于是，网站B就通过盗用保存在客户端的cookie，以客户端的身份来访问网站A，做一些诸如：发送信息，邮件，盗取账户，财产等违法操作。<br /></p><p><br /></p><p>由于我们现在使用的都是多窗口的浏览器，例如chorme、firefox、360浏览器等等。在带来方便的同时，也方便了CSRF的攻击，因为多窗口的浏览器都是单进程的，每个窗口的会话是共享的，所以会话信息很容易被利用。<br /></p><p><br /></p><p>那么，如何预防CSRF呢？其实防范CSRF的思想都是一致的，就是增加伪随机数(token)的验证。</p><p><br /></p><ol start=\"1\"><li>通过 referer、token 或者 验证码 来检测用户提交.例如：</li></ol><ol data-lake-indent=\"1\"><li>在标签加入token：<pre><code>&lt;meta content=&quot;_csrf&quot; name=&quot;csrf-param&quot;&gt;\n&lt;meta content=&quot;6eEHcEur-Q-CoC0eMc3GIRofusFMhD6fYr4Y&quot; name=&quot;csrf-token&quot;&gt;</code></pre></li><li>在表单加入token:<pre><code>&lt;input type=&quot;hidden&quot; name=&quot;csrf_token&quot; value=&quot;&lt;? echo $token;?&gt;&quot;&gt;</code></pre></li><li>请求操作要求输入验证码.(ps：这个一定程度上会影响用户体验)</li></ol><ol start=\"2\"><li>尽量不要在页面的链接中暴露用户隐私信息.</li><li>尽量使用post进行表单提交</li><li><span>避免全站通用的cookie，严格设置cookie的域</span></li></ol><p>目前来说，做好以上几点，几乎能防范99%的CSRF攻击啦。哈哈~</p>",
    "body_lake": "<!doctype lake><p>date: 2017-03-28 23:08:32</p><p>categories: '前端'</p><p>tags<cursor />: ['web安全']</p><card type=\"block\" name=\"hr\"></card><p>CSRF(Cross Site Request Forgery,跨站请求伪造)攻击是一种依赖web浏览器的、被混淆过的代理人攻击，通过伪装来自受信任用户的请求来利用受信任的网站，造成个人隐私泄露及财产安全。</p><p>&lt;!-- more --&gt;</p><p><br /></p><p>那么，CSRF攻击是怎样的流程呢？</p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F155457%2F1547264911153-67d7ef97-78a3-428a-b629-51ea80340304.png%22%2C%22originWidth%22%3A726%2C%22originHeight%22%3A459%2C%22name%22%3A%22CSRF%E6%94%BB%E5%87%BB%E5%9B%BE%E8%A7%A3.png%22%2C%22size%22%3A17843%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22width%22%3A726%2C%22height%22%3A459%7D\"></card></p><p><br /></p><ol start=\"1\"><li><p>step1: 客户端向网站A发起了通信请求</p></li></ol><ol start=\"2\"><li><p>step2: 网站A验证通过，并建立了通信连接，在客户端保存了A的cookie.</p></li></ol><ol start=\"3\"><li><p>step3: 客户端在未关闭与A的连接的情况下访问了网站B.</p></li></ol><ol start=\"4\"><li><p>step4: 网站B含有恶意请求代码，要求向网站A发起请求.</p></li></ol><ol start=\"5\"><li><p>step5：客户端根据B发起的请求并携带已保存的网站A的cookie访问网站A.</p></li></ol><ol start=\"6\"><li><p>step6: 网站A验证cookie并处理了这个请求.</p></li></ol><p><br /></p><p>于是，网站B就通过盗用保存在客户端的cookie，以客户端的身份来访问网站A，做一些诸如：发送信息，邮件，盗取账户，财产等违法操作。<br /></p><p><br /></p><p>由于我们现在使用的都是多窗口的浏览器，例如chorme、firefox、360浏览器等等。在带来方便的同时，也方便了CSRF的攻击，因为多窗口的浏览器都是单进程的，每个窗口的会话是共享的，所以会话信息很容易被利用。<br /></p><p><br /></p><p>那么，如何预防CSRF呢？其实防范CSRF的思想都是一致的，就是增加伪随机数(token)的验证。</p><p><br /></p><ol start=\"1\"><li>通过 referer、token 或者 验证码 来检测用户提交.例如：</li></ol><ol data-lake-indent=\"1\"><li>在标签加入token：<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22code%22%3A%22%3Cmeta%20content%3D%5C%22_csrf%5C%22%20name%3D%5C%22csrf-param%5C%22%3E%5Cn%3Cmeta%20content%3D%5C%226eEHcEur-Q-CoC0eMc3GIRofusFMhD6fYr4Y%5C%22%20name%3D%5C%22csrf-token%5C%22%3E%22%7D\"></card></li><li>在表单加入token:<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22plain%22%2C%22code%22%3A%22%3Cinput%20type%3D%5C%22hidden%5C%22%20name%3D%5C%22csrf_token%5C%22%20value%3D%5C%22%3C%3F%20echo%20%24token%3B%3F%3E%5C%22%3E%22%7D\"></card></li><li>请求操作要求输入验证码.(ps：这个一定程度上会影响用户体验)</li></ol><ol start=\"2\"><li>尽量不要在页面的链接中暴露用户隐私信息.</li><li>尽量使用post进行表单提交</li><li><span>避免全站通用的cookie，严格设置cookie的域</span></li></ol><p>目前来说，做好以上几点，几乎能防范99%的CSRF攻击啦。哈哈~</p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-01-12T04:14:32.000Z",
    "deleted_at": null,
    "created_at": "2019-01-12T03:47:30.000Z",
    "updated_at": "2019-01-12T04:14:32.000Z",
    "published_at": "2019-01-12T04:14:32.000Z",
    "first_published_at": "2019-01-12T03:51:49.000Z",
    "word_count": 565,
    "cover": null,
    "description": "date: 2017-03-28 23:08:32categories: '前端'tags: ['web安全']CSRF(Cross Site Request Forgery,跨站请求伪造)攻击是一种依赖web浏览器的、被混淆过的代理人攻击，通过伪装来自受信任用户的请求来利用受信任的网站，造成...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1138544,
    "slug": "mpta3h",
    "title": "web安全之DNS劫持",
    "book_id": 199054,
    "book": {
      "id": 199054,
      "type": "Book",
      "slug": "blog",
      "name": "博客",
      "user_id": 155457,
      "description": "前端技术博客存档",
      "creator_id": 155457,
      "public": 1,
      "items_count": 15,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-04-23T09:00:45.336Z",
      "updated_at": "2019-04-23T09:00:45.000Z",
      "created_at": "2019-01-06T05:57:32.000Z",
      "namespace": "u46795/blog",
      "user": {
        "id": 155457,
        "type": "User",
        "login": "u46795",
        "name": "Nero",
        "description": "https://github.com/Ghostdar",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 5,
        "public_books_count": 5,
        "followers_count": 12,
        "following_count": 5,
        "created_at": "2018-08-04T03:45:56.000Z",
        "updated_at": "2019-04-30T15:08:36.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 155457,
    "creator": {
      "id": 155457,
      "type": "User",
      "login": "u46795",
      "name": "Nero",
      "description": "https://github.com/Ghostdar",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 5,
      "public_books_count": 5,
      "followers_count": 12,
      "following_count": 5,
      "created_at": "2018-08-04T03:45:56.000Z",
      "updated_at": "2019-04-30T15:08:36.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "date: 2017-03-27 21:08:33<br />categories: '前端'<br />tags: ['web安全']\n\n---\n\n什么是DNS劫持？DNS劫持就是通过劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致对该域名的访问由原IP地址转入到修改后的指定IP，其结果就是对特定的网址不能访问或访问的是假网址，从而实现窃取资料或者破坏原有正常服务的目的。<br /><!-- more -->\n\n在讲DNS劫持之前，让我们来了解一下DNS解析的过程：\n\n![DNS解析过程.png](https://cdn.nlark.com/yuque/0/2019/png/155457/1547264801012-9e41240d-e67a-4065-a212-67da135806c9.png#align=left&display=inline&height=339&name=DNS%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B.png&originHeight=496&originWidth=1091&size=30327&width=746)\n\n- step1:客户机输入域名(以百度为例):www.baidu.com ，系统会先检查自己的本地hosts文件中是否有这个网址映射关系，若有进入step2，若无，则查找本地DNS解析器缓存，有则进入step2，无则进入step3。\n\n- step2: 缓存或hosts文件返回IP地址映射关系，并完成域名解析.\n\n- step3：查询本地服务器，若查询的域名在本地区域资源中（具有权威性）或区域服务器中有该域名缓存（不具权威性），则进入step10，否则进入step4.\n\n- step4：本地DNS服务器向13台根DNS服务器发起请求\n\n- step5：根服务器判断域名(.com)属于哪台GTLD服务器管理，并返回GTLD服务器IP\n\n- step6：本地DNS服务器向GTLD服务器发起请求.\n\n- step7：(.com)GTLD服务器返回域名(www.baidu.com)的主机IP给本地DNS服务器.\n\n- step8: 本地DNS服务器像(www.baidu.com)目的主机发送请求.\n\n- step9: 目的主机(www.baidu.com)返回主机IP给本地DNS服务器.\n\n- step10: 本地DNS服务器返回目的主机IP给客户机，完成解析.\n\n\n那么当有人劫持了DNS服务器，返回了错误的IP地址，会出现什么结果呢？\n\n![](/img/DNS劫持图解.png#)<br />![DNS劫持图解.png](https://cdn.nlark.com/yuque/0/2019/png/155457/1547264814315-853ef6bc-a384-4ce4-ad1d-800e7fda3a54.png#align=left&display=inline&height=332&name=DNS%E5%8A%AB%E6%8C%81%E5%9B%BE%E8%A7%A3.png&originHeight=490&originWidth=1101&size=36903&width=746)<br />是不是发现了？你访问的网址会失去响应或者跳到别的恶意网站，是不是会怀疑自己访问的是个假网址？哈哈..<br />\n\nDNS劫持一方面可能影响用户的正常体验，用户被引到假冒的网站进而无法正常浏览网页。用户量较大的网站域名被劫持后恶劣影响会不断扩大，用户可能被诱骗到冒牌网站进行登录等操作导致泄露隐私数据.<br />\n\n那么，在已经被劫持后，该怎么做呢？\n\n1. 修改域名服务商和邮箱密码，定期更换复杂度高的密码.\n\n2. 删除无用的DNS解析,恢复DNS设置，关闭域名的泛解析.\n\n3. 排查网站代码，清除垃圾页面.\n\n4. 收集非法添加的页面并设置404,使用百度站长工具提交死链.\n\n5. 若使用的是第三方DNS服务，则立即修改第三方DNS服务端账户密码，锁定账户信息,开启邮件或短信提醒.\n\n6. 更换服务商.\n\n\n那么我们该如何预防DNS劫持呢？\n\n1. 为域名注册商和注册用邮箱设置复杂密码且经常更换.\n\n2. 将域名更新设置为锁定状态，不允许通过DNS服务商网站修改记录，使用此方法后，需要做域名解析都要通过服务商来完成，时效性较差。\n\n3. 定期检查域名帐户信息、域名whois信息，査看事件管理器，清理Web网点中存在的可疑文件.\n\n4. 加强网站的防SQL注入功能，SQL注入是利用SQL语句的特点向数据库写内容，从而获取到权限的方法.\n\n5. 设置Web站点文件夹及文件操作权限.\n\n6. 利用事务签名对区域传送和区域更新进行数字签名.\n\n7. 删除运行在DNS服务器上的不必要服务.\n\n8. 在网络外围和DNS服务器上使用防火墙服务.\n\n\n相信做好以上几点，DNS劫持是很难发生啦~\n",
    "body_draft": "",
    "body_html": "<p>date: 2017-03-27 21:08:33</p><p>categories: '前端'</p><p>tags: ['web安全']</p><hr /><p>什么是DNS劫持？DNS劫持就是通过劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致对该域名的访问由原IP地址转入到修改后的指定IP，其结果就是对特定的网址不能访问或访问的是假网址，从而实现窃取资料或者破坏原有正常服务的目的。</p><p>&lt;!-- more --&gt;</p><p><br /></p><p>在讲DNS劫持之前，让我们来了解一下DNS解析的过程：<br /></p><p><img alt=\"DNS解析过程.png\" title=\"DNS解析过程.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/155457/1547264801012-9e41240d-e67a-4065-a212-67da135806c9.png#align=left&amp;display=inline&amp;height=339&amp;name=DNS%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B.png&amp;originHeight=496&amp;originWidth=1091&amp;size=30327&amp;width=746\" style=\"max-width: 600px; width: 746px;\" /></p><ul><li><p>step1:客户机输入域名(以百度为例):www.baidu.com ，系统会先检查自己的本地hosts文件中是否有这个网址映射关系，若有进入step2，若无，则查找本地DNS解析器缓存，有则进入step2，无则进入step3。</p></li></ul><ul><li><p>step2: 缓存或hosts文件返回IP地址映射关系，并完成域名解析.</p></li></ul><ul><li><p>step3：查询本地服务器，若查询的域名在本地区域资源中（具有权威性）或区域服务器中有该域名缓存（不具权威性），则进入step10，否则进入step4.</p></li></ul><ul><li><p>step4：本地DNS服务器向13台根DNS服务器发起请求</p></li></ul><ul><li><p>step5：根服务器判断域名(.com)属于哪台GTLD服务器管理，并返回GTLD服务器IP</p></li></ul><ul><li><p>step6：本地DNS服务器向GTLD服务器发起请求.</p></li></ul><ul><li><p>step7：(.com)GTLD服务器返回域名(www.baidu.com)的主机IP给本地DNS服务器.</p></li></ul><ul><li><p>step8: 本地DNS服务器像(www.baidu.com)目的主机发送请求.</p></li></ul><ul><li><p>step9: 目的主机(www.baidu.com)返回主机IP给本地DNS服务器.</p></li></ul><ul><li><p>step10: 本地DNS服务器返回目的主机IP给客户机，完成解析.</p></li></ul><p><br /></p><p>那么当有人劫持了DNS服务器，返回了错误的IP地址，会出现什么结果呢？</p><p><br /></p><p><img src=\"/img/DNS劫持图解.png#\" style=\"max-width: 600px;\" /></p><p><img alt=\"DNS劫持图解.png\" title=\"DNS劫持图解.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/155457/1547264814315-853ef6bc-a384-4ce4-ad1d-800e7fda3a54.png#align=left&amp;display=inline&amp;height=332&amp;name=DNS%E5%8A%AB%E6%8C%81%E5%9B%BE%E8%A7%A3.png&amp;originHeight=490&amp;originWidth=1101&amp;size=36903&amp;width=746\" style=\"max-width: 600px; width: 746px;\" /></p><p>是不是发现了？你访问的网址会失去响应或者跳到别的恶意网站，是不是会怀疑自己访问的是个假网址？哈哈..<br /></p><p><br /></p><p>DNS劫持一方面可能影响用户的正常体验，用户被引到假冒的网站进而无法正常浏览网页。用户量较大的网站域名被劫持后恶劣影响会不断扩大，用户可能被诱骗到冒牌网站进行登录等操作导致泄露隐私数据.<br /></p><p><br /></p><p>那么，在已经被劫持后，该怎么做呢？</p><p><br /></p><ol start=\"1\"><li><p>修改域名服务商和邮箱密码，定期更换复杂度高的密码.</p></li></ol><ol start=\"2\"><li><p>删除无用的DNS解析,恢复DNS设置，关闭域名的泛解析.</p></li></ol><ol start=\"3\"><li><p>排查网站代码，清除垃圾页面.</p></li></ol><ol start=\"4\"><li><p>收集非法添加的页面并设置404,使用百度站长工具提交死链.</p></li></ol><ol start=\"5\"><li><p>若使用的是第三方DNS服务，则立即修改第三方DNS服务端账户密码，锁定账户信息,开启邮件或短信提醒.</p></li></ol><ol start=\"6\"><li><p>更换服务商.</p></li></ol><p><br /></p><p>那么我们该如何预防DNS劫持呢？</p><p><br /></p><ol start=\"1\"><li><p>为域名注册商和注册用邮箱设置复杂密码且经常更换.</p></li></ol><ol start=\"2\"><li><p>将域名更新设置为锁定状态，不允许通过DNS服务商网站修改记录，使用此方法后，需要做域名解析都要通过服务商来完成，时效性较差。</p></li></ol><ol start=\"3\"><li><p>定期检查域名帐户信息、域名whois信息，査看事件管理器，清理Web网点中存在的可疑文件.</p></li></ol><ol start=\"4\"><li><p>加强网站的防SQL注入功能，SQL注入是利用SQL语句的特点向数据库写内容，从而获取到权限的方法.</p></li></ol><ol start=\"5\"><li><p>设置Web站点文件夹及文件操作权限.</p></li></ol><ol start=\"6\"><li><p>利用事务签名对区域传送和区域更新进行数字签名.</p></li></ol><ol start=\"7\"><li><p>删除运行在DNS服务器上的不必要服务.</p></li></ol><ol start=\"8\"><li><p>在网络外围和DNS服务器上使用防火墙服务.</p></li></ol><p><br /></p><p>相信做好以上几点，DNS劫持是很难发生啦~</p>",
    "body_lake": "<!doctype lake><p>date: 2017-03-27 21:08:33</p><p>categories: '前端'</p><p>tags: ['web安全']</p><card type=\"block\" name=\"hr\"></card><p>什么是DNS劫持？DNS劫持就是通过劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致对该域名的访问由原IP地址转入到修改后的指定IP，其结果就是对特定的网址不能访问或访问的是假网址，从而实现窃取资料或者破坏原有正常服务的目的。</p><p>&lt;!-- more --&gt;</p><p><br /></p><p>在讲DNS劫持之前，让我们来了解一下DNS解析的过程：<br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F155457%2F1547264801012-9e41240d-e67a-4065-a212-67da135806c9.png%22%2C%22originWidth%22%3A1091%2C%22originHeight%22%3A496%2C%22name%22%3A%22DNS%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B.png%22%2C%22size%22%3A30327%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22width%22%3A746%2C%22height%22%3A339%7D\"></card></p><ul><li><p>step1:客户机输入域名(以百度为例):www.baidu.com ，系统会先检查自己的本地hosts文件中是否有这个网址映射关系，若有进入step2，若无，则查找本地DNS解析器缓存，有则进入step2，无则进入step3。</p></li></ul><ul><li><p>step2: 缓存或hosts文件返回IP地址映射关系，并完成域名解析.</p></li></ul><ul><li><p>step3：查询本地服务器，若查询的域名在本地区域资源中（具有权威性）或区域服务器中有该域名缓存（不具权威性），则进入step10，否则进入step4.</p></li></ul><ul><li><p>step4：本地DNS服务器向13台根DNS服务器发起请求</p></li></ul><ul><li><p>step5：根服务器判断域名(.com)属于哪台GTLD服务器管理，并返回GTLD服务器IP</p></li></ul><ul><li><p>step6：本地DNS服务器向GTLD服务器发起请求.</p></li></ul><ul><li><p>step7：(.com)GTLD服务器返回域名(www.baidu.com)的主机IP给本地DNS服务器.</p></li></ul><ul><li><p>step8: 本地DNS服务器像(www.baidu.com)目的主机发送请求.</p></li></ul><ul><li><p>step9: 目的主机(www.baidu.com)返回主机IP给本地DNS服务器.</p></li></ul><ul><li><p>step10: 本地DNS服务器返回目的主机IP给客户机，完成解析.</p></li></ul><p><br /></p><p>那么当有人劫持了DNS服务器，返回了错误的IP地址，会出现什么结果呢？</p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22%2Fimg%2FDNS%E5%8A%AB%E6%8C%81%E5%9B%BE%E8%A7%A3.png%22%7D\"></card></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F155457%2F1547264814315-853ef6bc-a384-4ce4-ad1d-800e7fda3a54.png%22%2C%22originWidth%22%3A1101%2C%22originHeight%22%3A490%2C%22name%22%3A%22DNS%E5%8A%AB%E6%8C%81%E5%9B%BE%E8%A7%A3.png%22%2C%22size%22%3A36903%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22width%22%3A746%2C%22height%22%3A332%7D\"></card></p><p>是不是发现了？你访问的网址会失去响应或者跳到别的恶意网站，是不是会怀疑自己访问的是个假网址？哈哈..<br /></p><p><br /></p><p>DNS劫持一方面可能影响用户的正常体验，用户被引到假冒的网站进而无法正常浏览网页。用户量较大的网站域名被劫持后恶劣影响会不断扩大，用户可能被诱骗到冒牌网站进行登录等操作导致泄露隐私数据.<br /></p><p><br /></p><p>那么，在已经被劫持后，该怎么做呢？</p><p><br /></p><ol start=\"1\"><li><p>修改域名服务商和邮箱密码，定期更换复杂度高的密码.</p></li></ol><ol start=\"2\"><li><p>删除无用的DNS解析,恢复DNS设置，关闭域名的泛解析.</p></li></ol><ol start=\"3\"><li><p>排查网站代码，清除垃圾页面.</p></li></ol><ol start=\"4\"><li><p>收集非法添加的页面并设置404,使用百度站长工具提交死链.</p></li></ol><ol start=\"5\"><li><p>若使用的是第三方DNS服务，则立即修改第三方DNS服务端账户密码，锁定账户信息,开启邮件或短信提醒.</p></li></ol><ol start=\"6\"><li><p>更换服务商.</p></li></ol><p><br /></p><p>那么我们该如何预防DNS劫持呢？</p><p><br /></p><ol start=\"1\"><li><p>为域名注册商和注册用邮箱设置复杂密码且经常更换.</p></li></ol><ol start=\"2\"><li><p>将域名更新设置为锁定状态，不允许通过DNS服务商网站修改记录，使用此方法后，需要做域名解析都要通过服务商来完成，时效性较差。</p></li></ol><ol start=\"3\"><li><p>定期检查域名帐户信息、域名whois信息，査看事件管理器，清理Web网点中存在的可疑文件.</p></li></ol><ol start=\"4\"><li><p>加强网站的防SQL注入功能，SQL注入是利用SQL语句的特点向数据库写内容，从而获取到权限的方法.</p></li></ol><ol start=\"5\"><li><p>设置Web站点文件夹及文件操作权限.</p></li></ol><ol start=\"6\"><li><p>利用事务签名对区域传送和区域更新进行数字签名.</p></li></ol><ol start=\"7\"><li><p>删除运行在DNS服务器上的不必要服务.</p></li></ol><ol start=\"8\"><li><p>在网络外围和DNS服务器上使用防火墙服务.</p></li></ol><p><br /></p><p>相信做好以上几点，DNS劫持是很难发生啦~</p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-01-12T04:14:21.000Z",
    "deleted_at": null,
    "created_at": "2019-01-12T03:44:36.000Z",
    "updated_at": "2019-01-12T04:14:21.000Z",
    "published_at": "2019-01-12T04:14:21.000Z",
    "first_published_at": "2019-01-12T03:47:08.000Z",
    "word_count": 1009,
    "cover": null,
    "description": "date: 2017-03-27 21:08:33categories: '前端'tags: ['web安全']什么是DNS劫持？DNS劫持就是通过劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致对该域名的访问由原IP地址转入到修改后的指定IP，其结果...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1138539,
    "slug": "xc246i",
    "title": "Mysql笔记",
    "book_id": 199054,
    "book": {
      "id": 199054,
      "type": "Book",
      "slug": "blog",
      "name": "博客",
      "user_id": 155457,
      "description": "前端技术博客存档",
      "creator_id": 155457,
      "public": 1,
      "items_count": 15,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-04-23T09:00:45.336Z",
      "updated_at": "2019-04-23T09:00:45.000Z",
      "created_at": "2019-01-06T05:57:32.000Z",
      "namespace": "u46795/blog",
      "user": {
        "id": 155457,
        "type": "User",
        "login": "u46795",
        "name": "Nero",
        "description": "https://github.com/Ghostdar",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 5,
        "public_books_count": 5,
        "followers_count": 12,
        "following_count": 5,
        "created_at": "2018-08-04T03:45:56.000Z",
        "updated_at": "2019-04-30T15:08:36.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 155457,
    "creator": {
      "id": 155457,
      "type": "User",
      "login": "u46795",
      "name": "Nero",
      "description": "https://github.com/Ghostdar",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 5,
      "public_books_count": 5,
      "followers_count": 12,
      "following_count": 5,
      "created_at": "2018-08-04T03:45:56.000Z",
      "updated_at": "2019-04-30T15:08:36.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "date: 2017-03-19 18:27:01<br />categories: '数据库'<br />tag: ['mysql']\n\n---\n\nmysql 是关系型数据库中的一种，在使用的过程中，我会遇到许多问题，我将不定时更新，这篇文章将记录我与mysql的点点滴滴。\n\n<!-- more -->\n<a name=\"9faafc14\"></a>\n# mysql通信协议：\n\n1. TCP/IP协议，通常我们通过来连接MySQL，各种主要编程语言都是根据这个协议实现了连接模块\n\n2. Unix Socket协议，这个通常我们登入MySQL服务器中使用这个协议，因为要使用这个协议连接MySQL需要一个物理文件，文件的存放位置在配置文件中有定义，值得一提的是，这是所有协议中最高效的一个。\n\n3. Share Memory（共享内存）协议，这个协议一般人不知道，肯定也没用过，因为这个只有windows可以使用，使用这个协议需要在配置文件中在启动的时候使用–shared-memory参数，注意的是，使用此协议，一个host上只能有一个server，所以这个东西一般没啥用的，除非你怀疑其他协议不能正常工作，实际上微软的SQL Sever也支持这个协议。\n\n4. Named Pipes(命名管道)协议，这个协议也是只有windows才可以用，同shared memory一样，使用此协议，一个host上依然只能有一个server，即使是使用不同的端口也不行，Named Pipes 是为局域网而开发的协议。内存的一部分被某个进程用来向另一个进程传递信息，因此一个进程的输出就是另一个进程的输入。第二个进程可以是本地的（与第一个进程位于同一台计算机上），也可以是远程的（位于联网的计算机上）。正因为如此，假如你的环境中没有或者禁用TCP/IP环境，而且是windows服务器，那么好歹你的数据库还能工作。使用这个协议需要在启动的时候添加–enable-named-pipe选项。\n\n\n<a name=\"04ffc116\"></a>\n# SQL支持的四种备份类型：\n\n1. 完全数据库备份。\n\n2. 差异备份或者增量备份。\n\n3. 事物日子备份。\n\n4. 文件、文件组备份。\n\n\n<a name=\"cc743957\"></a>\n# mysql 设计三范式：\n\n1. 1NF--原子性：数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。如果实体中的某个属性有多个值时，必须拆分为不同的属性 。通俗理解即一个字段只存储一项信息。\n\n2. 2NF--唯一性：第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要我们设计一个主键来实现(这里的主键不包含业务逻辑)。即满足第一范式前提，当存在多个主键的时候，才会发生不符合第二范式的情况。比如有两个主键，不能存在这样的属性，它只依赖于其中一个主键，这就是不符合第二范式。通俗理解是任意一个字段都只依赖表中的同一个字段。（涉及到表的拆分）\n\n3. 3NF--非主键字段不能相互依赖:满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主键字段。就是说，表的信息，如果能够被推导出来，就不应该单独的设计一个字段来存放(能尽量外键join就用外键join)。很多时候，我们为了满足第三范式往往会把一张表分成多张表。即满足第二范式前提，如果某一属性依赖于其他非主键属性，而其他非主键属性又依赖于主键，那么这个属性就是间接依赖于主键，这被称作传递依赖于主属性。 通俗解释就是一张表最多只存两层同类型信息。\n\n\n<a name=\"d41d8cd9\"></a>\n# \n",
    "body_draft": "",
    "body_html": "<p>date: 2017-03-19 18:27:01</p><p>categories: '数据库'</p><p>tag: ['mysql']</p><hr /><p>mysql 是关系型数据库中的一种，在使用的过程中，我会遇到许多问题，我将不定时更新，这篇文章将记录我与mysql的点点滴滴。</p><p><br /></p><p>&lt;!-- more --&gt;</p><h1 id=\"9faafc14\">mysql通信协议：</h1><p><br /></p><ol start=\"1\"><li><p>TCP/IP协议，通常我们通过来连接MySQL，各种主要编程语言都是根据这个协议实现了连接模块</p></li></ol><ol start=\"2\"><li><p>Unix Socket协议，这个通常我们登入MySQL服务器中使用这个协议，因为要使用这个协议连接MySQL需要一个物理文件，文件的存放位置在配置文件中有定义，值得一提的是，这是所有协议中最高效的一个。</p></li></ol><ol start=\"3\"><li><p>Share Memory（共享内存）协议，这个协议一般人不知道，肯定也没用过，因为这个只有windows可以使用，使用这个协议需要在配置文件中在启动的时候使用–shared-memory参数，注意的是，使用此协议，一个host上只能有一个server，所以这个东西一般没啥用的，除非你怀疑其他协议不能正常工作，实际上微软的SQL Sever也支持这个协议。</p></li></ol><ol start=\"4\"><li><p>Named Pipes(命名管道)协议，这个协议也是只有windows才可以用，同shared memory一样，使用此协议，一个host上依然只能有一个server，即使是使用不同的端口也不行，Named Pipes 是为局域网而开发的协议。内存的一部分被某个进程用来向另一个进程传递信息，因此一个进程的输出就是另一个进程的输入。第二个进程可以是本地的（与第一个进程位于同一台计算机上），也可以是远程的（位于联网的计算机上）。正因为如此，假如你的环境中没有或者禁用TCP/IP环境，而且是windows服务器，那么好歹你的数据库还能工作。使用这个协议需要在启动的时候添加–enable-named-pipe选项。</p></li></ol><p><br /></p><h1 id=\"04ffc116\">SQL支持的四种备份类型：</h1><p><br /></p><ol start=\"1\"><li><p>完全数据库备份。</p></li></ol><ol start=\"2\"><li><p>差异备份或者增量备份。</p></li></ol><ol start=\"3\"><li><p>事物日子备份。</p></li></ol><ol start=\"4\"><li><p>文件、文件组备份。</p></li></ol><p><br /></p><h1 id=\"cc743957\">mysql 设计三范式：</h1><p><br /></p><ol start=\"1\"><li><p>1NF--原子性：数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。如果实体中的某个属性有多个值时，必须拆分为不同的属性 。通俗理解即一个字段只存储一项信息。</p></li></ol><ol start=\"2\"><li><p>2NF--唯一性：第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要我们设计一个主键来实现(这里的主键不包含业务逻辑)。即满足第一范式前提，当存在多个主键的时候，才会发生不符合第二范式的情况。比如有两个主键，不能存在这样的属性，它只依赖于其中一个主键，这就是不符合第二范式。通俗理解是任意一个字段都只依赖表中的同一个字段。（涉及到表的拆分）</p></li></ol><ol start=\"3\"><li><p>3NF--非主键字段不能相互依赖:满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主键字段。就是说，表的信息，如果能够被推导出来，就不应该单独的设计一个字段来存放(能尽量外键join就用外键join)。很多时候，我们为了满足第三范式往往会把一张表分成多张表。即满足第二范式前提，如果某一属性依赖于其他非主键属性，而其他非主键属性又依赖于主键，那么这个属性就是间接依赖于主键，这被称作传递依赖于主属性。 通俗解释就是一张表最多只存两层同类型信息。</p></li></ol><p><br /></p><h1 id=\"d41d8cd9\"><br /></h1>",
    "body_lake": "<!doctype lake><p>date: 2017-03-19 18:27:01</p><p>cate<cursor />gories: '数据库'</p><p>tag: ['mysql']</p><card type=\"block\" name=\"hr\"></card><p>mysql 是关系型数据库中的一种，在使用的过程中，我会遇到许多问题，我将不定时更新，这篇文章将记录我与mysql的点点滴滴。</p><p><br /></p><p>&lt;!-- more --&gt;</p><h1 id=\"9faafc14\">mysql通信协议：</h1><p><br /></p><ol start=\"1\"><li><p>TCP/IP协议，通常我们通过来连接MySQL，各种主要编程语言都是根据这个协议实现了连接模块</p></li></ol><ol start=\"2\"><li><p>Unix Socket协议，这个通常我们登入MySQL服务器中使用这个协议，因为要使用这个协议连接MySQL需要一个物理文件，文件的存放位置在配置文件中有定义，值得一提的是，这是所有协议中最高效的一个。</p></li></ol><ol start=\"3\"><li><p>Share Memory（共享内存）协议，这个协议一般人不知道，肯定也没用过，因为这个只有windows可以使用，使用这个协议需要在配置文件中在启动的时候使用–shared-memory参数，注意的是，使用此协议，一个host上只能有一个server，所以这个东西一般没啥用的，除非你怀疑其他协议不能正常工作，实际上微软的SQL Sever也支持这个协议。</p></li></ol><ol start=\"4\"><li><p>Named Pipes(命名管道)协议，这个协议也是只有windows才可以用，同shared memory一样，使用此协议，一个host上依然只能有一个server，即使是使用不同的端口也不行，Named Pipes 是为局域网而开发的协议。内存的一部分被某个进程用来向另一个进程传递信息，因此一个进程的输出就是另一个进程的输入。第二个进程可以是本地的（与第一个进程位于同一台计算机上），也可以是远程的（位于联网的计算机上）。正因为如此，假如你的环境中没有或者禁用TCP/IP环境，而且是windows服务器，那么好歹你的数据库还能工作。使用这个协议需要在启动的时候添加–enable-named-pipe选项。</p></li></ol><p><br /></p><h1 id=\"04ffc116\">SQL支持的四种备份类型：</h1><p><br /></p><ol start=\"1\"><li><p>完全数据库备份。</p></li></ol><ol start=\"2\"><li><p>差异备份或者增量备份。</p></li></ol><ol start=\"3\"><li><p>事物日子备份。</p></li></ol><ol start=\"4\"><li><p>文件、文件组备份。</p></li></ol><p><br /></p><h1 id=\"cc743957\">mysql 设计三范式：</h1><p><br /></p><ol start=\"1\"><li><p>1NF--原子性：数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。如果实体中的某个属性有多个值时，必须拆分为不同的属性 。通俗理解即一个字段只存储一项信息。</p></li></ol><ol start=\"2\"><li><p>2NF--唯一性：第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要我们设计一个主键来实现(这里的主键不包含业务逻辑)。即满足第一范式前提，当存在多个主键的时候，才会发生不符合第二范式的情况。比如有两个主键，不能存在这样的属性，它只依赖于其中一个主键，这就是不符合第二范式。通俗理解是任意一个字段都只依赖表中的同一个字段。（涉及到表的拆分）</p></li></ol><ol start=\"3\"><li><p>3NF--非主键字段不能相互依赖:满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主键字段。就是说，表的信息，如果能够被推导出来，就不应该单独的设计一个字段来存放(能尽量外键join就用外键join)。很多时候，我们为了满足第三范式往往会把一张表分成多张表。即满足第二范式前提，如果某一属性依赖于其他非主键属性，而其他非主键属性又依赖于主键，那么这个属性就是间接依赖于主键，这被称作传递依赖于主属性。 通俗解释就是一张表最多只存两层同类型信息。</p></li></ol><p><br /></p><h1 id=\"d41d8cd9\"><br /></h1>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-01-14T03:00:46.000Z",
    "deleted_at": null,
    "created_at": "2019-01-12T03:42:50.000Z",
    "updated_at": "2019-01-14T03:00:46.000Z",
    "published_at": "2019-01-14T03:00:46.000Z",
    "first_published_at": "2019-01-12T03:44:11.000Z",
    "word_count": 1075,
    "cover": null,
    "description": "date: 2017-03-19 18:27:01categories: '数据库'tag: ['mysql']mysql 是关系型数据库中的一种，在使用的过程中，我会遇到许多问题，我将不定时更新，这篇文章将记录我与mysql的点点滴滴。&lt;!-- more --&gt;mysql通信协议...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1138526,
    "slug": "rcel8f",
    "title": "http请求过程",
    "book_id": 199054,
    "book": {
      "id": 199054,
      "type": "Book",
      "slug": "blog",
      "name": "博客",
      "user_id": 155457,
      "description": "前端技术博客存档",
      "creator_id": 155457,
      "public": 1,
      "items_count": 15,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-04-23T09:00:45.336Z",
      "updated_at": "2019-04-23T09:00:45.000Z",
      "created_at": "2019-01-06T05:57:32.000Z",
      "namespace": "u46795/blog",
      "user": {
        "id": 155457,
        "type": "User",
        "login": "u46795",
        "name": "Nero",
        "description": "https://github.com/Ghostdar",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 5,
        "public_books_count": 5,
        "followers_count": 12,
        "following_count": 5,
        "created_at": "2018-08-04T03:45:56.000Z",
        "updated_at": "2019-04-30T15:08:36.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 155457,
    "creator": {
      "id": 155457,
      "type": "User",
      "login": "u46795",
      "name": "Nero",
      "description": "https://github.com/Ghostdar",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 5,
      "public_books_count": 5,
      "followers_count": 12,
      "following_count": 5,
      "created_at": "2018-08-04T03:45:56.000Z",
      "updated_at": "2019-04-30T15:08:36.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "date: 2017-03-17 23:19:35<br />tags: ['http']<br />categories: ['前端']\n\n---\n\nHTTP是一个应用层的协议，我们在浏览器浏览网页时，所用的就是http协议来与服务器通讯，那么，当从我们输入一个网址到网页上显示出内容的这个过程中，到底发生了什么呢？<br /><!-- more -->\n<a name=\"6efd79d7\"></a>\n# 请求过程：\n\n<a name=\"7e6a0233\"></a>\n#### 1. 输入url\n\n<a name=\"10b77e9a\"></a>\n#### 2. cache---查询强缓存，未过期则直接从缓存中提取数据。\n\n<a name=\"310f90d2\"></a>\n#### 3. DNS---强缓存过期，由DNS服务器解析目的IP，解析失败则返回错误。\n\n<a name=\"8e20e212\"></a>\n#### 4. TCP---找到目的IP，则发送请求报文，与服务器进行TCP 3次握手建立连接,成功后将数据流发送给代理服务器。\n\n<a name=\"8bca765a\"></a>\n#### 5. request---由代理服务器(Apache/Nginx)将http请求报文解析为php可读的request对象，由PHP进行逻辑处理。\n\n> apache处理请求：apache主进程接收所有请求后分给多个子进程处理每个请求，子进程将请求发到httpserver，由http服务器将请求转换为请求报文，交由CGI处理器，.php文件由php服务程序解析(parser)，进行逻辑处理，处理完后转成响应报文，返回给客户端。\n\n\n<a name=\"5bff8e01\"></a>\n#### 6. response---PHP处理完后，转为响应报文返回给客户端\n\n> - 正向代理:客户端发送请求到代理服务器，代理服务器发送请求到目的服务器，目的服务器返回数据给代理服务器，再由代理服务器返回给客户端。\n\n\n> - 反向代理:客户端发送请求给代理服务器，代理服务器通知目的服务器客户端的请求，由目的服务器直接返回数据给客户端。\n\n",
    "body_draft": "",
    "body_html": "<p>date: 2017-03-17 23:19:35</p><p>tags: ['http']</p><p>categories: ['前端']</p><hr /><p>HTTP是一个应用层的协议，我们在浏览器浏览网页时，所用的就是http协议来与服务器通讯，那么，当从我们输入一个网址到网页上显示出内容的这个过程中，到底发生了什么呢？</p><p>&lt;!-- more --&gt;</p><h1 id=\"6efd79d7\">请求过程：</h1><p><br /></p><h4 id=\"7e6a0233\">1. 输入url</h4><p><br /></p><h4 id=\"10b77e9a\">2. cache---查询强缓存，未过期则直接从缓存中提取数据。</h4><p><br /></p><h4 id=\"310f90d2\">3. DNS---强缓存过期，由DNS服务器解析目的IP，解析失败则返回错误。</h4><p><br /></p><h4 id=\"8e20e212\">4. TCP---找到目的IP，则发送请求报文，与服务器进行TCP 3次握手建立连接,成功后将数据流发送给代理服务器。</h4><p><br /></p><h4 id=\"8bca765a\">5. request---由代理服务器(Apache/Nginx)将http请求报文解析为php可读的request对象，由PHP进行逻辑处理。</h4><p><br /></p><blockquote><p>apache处理请求：apache主进程接收所有请求后分给多个子进程处理每个请求，子进程将请求发到httpserver，由http服务器将请求转换为请求报文，交由CGI处理器，.php文件由php服务程序解析(parser)，进行逻辑处理，处理完后转成响应报文，返回给客户端。</p></blockquote><p><br /></p><h4 id=\"5bff8e01\">6. response---PHP处理完后，转为响应报文返回给客户端</h4><p><br /></p><blockquote><ul><li>正向代理:客户端发送请求到代理服务器，代理服务器发送请求到目的服务器，目的服务器返回数据给代理服务器，再由代理服务器返回给客户端。</li></ul></blockquote><p><br /></p><blockquote><ul><li>反向代理:客户端发送请求给代理服务器，代理服务器通知目的服务器客户端的请求，由目的服务器直接返回数据给客户端。</li></ul></blockquote>",
    "body_lake": "<!doctype lake><p>date: 2017-03-17 23:19:35</p><p>tags: ['http']</p><p>cate<cursor />gories: ['前端']</p><card type=\"block\" name=\"hr\"></card><p>HTTP是一个应用层的协议，我们在浏览器浏览网页时，所用的就是http协议来与服务器通讯，那么，当从我们输入一个网址到网页上显示出内容的这个过程中，到底发生了什么呢？</p><p>&lt;!-- more --&gt;</p><h1 id=\"6efd79d7\">请求过程：</h1><p><br /></p><h4 id=\"7e6a0233\">1. 输入url</h4><p><br /></p><h4 id=\"10b77e9a\">2. cache---查询强缓存，未过期则直接从缓存中提取数据。</h4><p><br /></p><h4 id=\"310f90d2\">3. DNS---强缓存过期，由DNS服务器解析目的IP，解析失败则返回错误。</h4><p><br /></p><h4 id=\"8e20e212\">4. TCP---找到目的IP，则发送请求报文，与服务器进行TCP 3次握手建立连接,成功后将数据流发送给代理服务器。</h4><p><br /></p><h4 id=\"8bca765a\">5. request---由代理服务器(Apache/Nginx)将http请求报文解析为php可读的request对象，由PHP进行逻辑处理。</h4><p><br /></p><blockquote><p>apache处理请求：apache主进程接收所有请求后分给多个子进程处理每个请求，子进程将请求发到httpserver，由http服务器将请求转换为请求报文，交由CGI处理器，.php文件由php服务程序解析(parser)，进行逻辑处理，处理完后转成响应报文，返回给客户端。</p></blockquote><p><br /></p><h4 id=\"5bff8e01\">6. response---PHP处理完后，转为响应报文返回给客户端</h4><p><br /></p><blockquote><ul><li>正向代理:客户端发送请求到代理服务器，代理服务器发送请求到目的服务器，目的服务器返回数据给代理服务器，再由代理服务器返回给客户端。</li></ul></blockquote><p><br /></p><blockquote><ul><li>反向代理:客户端发送请求给代理服务器，代理服务器通知目的服务器客户端的请求，由目的服务器直接返回数据给客户端。</li></ul></blockquote>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-01-14T03:05:02.000Z",
    "deleted_at": null,
    "created_at": "2019-01-12T03:40:19.000Z",
    "updated_at": "2019-01-14T03:05:03.000Z",
    "published_at": "2019-01-14T03:05:02.000Z",
    "first_published_at": "2019-01-12T03:41:56.000Z",
    "word_count": 442,
    "cover": null,
    "description": "date: 2017-03-17 23:19:35tags: ['http']categories: ['前端']HTTP是一个应用层的协议，我们在浏览器浏览网页时，所用的就是http协议来与服务器通讯，那么，当从我们输入一个网址到网页上显示出内容的这个过程中，到底发生了什么呢？&lt;!--...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1138515,
    "slug": "uqcmfu",
    "title": "API设计规范",
    "book_id": 199054,
    "book": {
      "id": 199054,
      "type": "Book",
      "slug": "blog",
      "name": "博客",
      "user_id": 155457,
      "description": "前端技术博客存档",
      "creator_id": 155457,
      "public": 1,
      "items_count": 15,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-04-23T09:00:45.336Z",
      "updated_at": "2019-04-23T09:00:45.000Z",
      "created_at": "2019-01-06T05:57:32.000Z",
      "namespace": "u46795/blog",
      "user": {
        "id": 155457,
        "type": "User",
        "login": "u46795",
        "name": "Nero",
        "description": "https://github.com/Ghostdar",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 5,
        "public_books_count": 5,
        "followers_count": 12,
        "following_count": 5,
        "created_at": "2018-08-04T03:45:56.000Z",
        "updated_at": "2019-04-30T15:08:36.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 155457,
    "creator": {
      "id": 155457,
      "type": "User",
      "login": "u46795",
      "name": "Nero",
      "description": "https://github.com/Ghostdar",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 5,
      "public_books_count": 5,
      "followers_count": 12,
      "following_count": 5,
      "created_at": "2018-08-04T03:45:56.000Z",
      "updated_at": "2019-04-30T15:08:36.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "date: 2017-03-30 00:41:45<br />categories: ['前端']<br />tags: ['RESTfulAPI','后端']\n\n---\n\n\n\n    [\n      \n    ]()\n  \n    [\n      \n    ]()\n  API(Application Programming Interface,应用程序编程接口)是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。简单的说，API就是通过某一预先定义的渠道读/写数据的方式。由于技术的发展，前后分离模式已经成为主流，且前端设备层出不穷，于是为统一前后端通信的机制，WEB API应运而生。下面我就从发起一个请求到返回数据的过程中，聊一聊API的设计规范。<br /><!-- more -->\n<a name=\"12ccbaff\"></a>\n## 一. 初识 RESTful API\n\n<a name=\"e6240c27\"></a>\n#### 1. RESTful架构的前世今生：\n\nREST(Representational State Transfer,表层状态转化)是由是Roy Thomas Fielding(HTTP协议（1.0版和1.1版）的主要设计者、Apache服务器软件的作者之一、Apache基金会的第一任主席)在他2000年的博士论文中提出的，而如果一个架构符合REST原则，那就称之为RESTful架构。\n\n<a name=\"cf100273\"></a>\n#### 2. 浅析RESTful架构（资源表现层状态转化）：\n\n- 资源：资源即网络上的一个实体，如文本、图片、歌曲，甚至一种服务，也可以称之为资源，而URI(统一资源标识符)是指向某一种资源的唯一标识，我们上网，就是通过URI与某些资源进行互动的过程。\n\n- 表现层：“资源”是一种信息实体，它可以有多种外在表现形式(html、xml、json、jpg等)。我们把“资源”具体呈现出来的形式，叫做它的“表现层”（Representation）。URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的“.html”后缀名是不必要的，因为这个后缀名表示格式，属于\"表现层\"范畴，而URI应该只代表\"资源\"的位置。HTTP请求的头信息中ccept和Content-Type字段用于对“表现层”的描述。\n\n- 状态转化：互联网通信协议HTTP协议是一个无状态协议,状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生“状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是“表现层状态转化”。客户端用到的手段，就是HTTP协议里面，四个表示操作方式的动词：GET(获取资源)、POST(新建/更新资源)、PUT(更新资源)、DELETE(删除资源)。\n\n\n<a name=\"3739b886\"></a>\n#### 3. 总结：\n\n- 一个URI代表一种资源.\n- 客户端和服务器之间，传递这种资源的某种表现层.\n- 客户端通过四个HTTP动词，对服务器端资源进行操作，实现\"表现层状态转化\".\n\n<a name=\"0bcc7786\"></a>\n## 二. RESTful API的设计规范\n\n<a name=\"d84de8d5\"></a>\n#### 1. URI\n\n- **协议**：<br />API与用户的通信协议应为：HTTPS（以安全为目标的HTTP通道，即HTTP下加入SSL层，用于加密和身份验证。）\n\n- **域名**：<br />应将API尽量放入专用域名之下：\n\n\n```\nhttps://api.youwebsite.com\n```\n\n若只是简单的API且不会继续扩展，可放入主域名之下：\n\n```\nhttps://youwebsite.com/api/\n```\n\n- **路径**：<br />路径是API中的具体网址，在RESTful架构中，每一个网址代表一种资源，所以URL中不能有动词，只能有名词，而且所有的名词一般与数据库中的表名相对应，数据库中每个表都是一种资源的集合，所以API中的名词应该使用负数，如：\n```\nhttps://api.youwebsite.com/v1/bookracks    //代表书架的集合\n\nhttps://api.youwebsite.com/v1/bookracks/category   //代表书架的分类\n\nhttps://api.youwebsite.com/v1/manager  //代表书架的管理员\n```\n\n- **复杂查询**:\n\n\n|  | 示例 | 备注 |\n| --- | --- | --- |\n| 过滤条件 | ?type=1&num=6 | 允许一定冗余，如/books/1可以写成/books?id=1 |\n| 排序 | ?sort=page,desc |  |\n| 投影 | ?userinfo=id,name,email |  |\n| 分页 | ?limit=10&offset=3 |  |\n\n\n- **Bookmarker**:<br />\n经常使用的、复杂的查询标签化，降低维护成本。如：\n\n```\n/trades?status=closed&sort=created,desc\n\n可以写成：\n\nGET /trades/recently-closed\n```\n\n<a name=\"bcb0194d\"></a>\n#### 2. request\n\n- **HTTP方法**:<br />常用的动词：\n\n  - GET(select): 从服务器取出资源\n\n  - POST(create): 在服务器创建一个资源\n\n  - PUT(update): 在服务器更新资源（客户提供改变后的完整资源，如改变用户的信息）\n\n  - PATCH(update): 在服务器更新资源（客户提供改变的属性，如修改用户的状态）\n\n  - DELETE(delete): 从服务器删除资源\n\n\n不常用的动词：\n\n  - HEAD: 获取资源的元数据\n\n  - OPTIONS: 获取信息，关于资源的哪些属性客户是可以改变的\n\n- **header**\n\n  - Content-Type：<br />\n1.Content-Type:application/json\n```\nPOST /v1/animal HTTP/1.1\nHost: api.youwebsite.com\nAccept: application/json\nContent-Type: application/json\nContent-Length: 24\n\n{   \n  \"name\": \"Sir H\",\n  \"age\": \"12\"\n}\n```\n2.Content-Type:application/x-www-form-urlencoded\n```\nPOST /login HTTP/1.1\nHost: example.com\nContent-Length: 31\nAccept: text/html\nContent-Type: application/x-www-form-urlencoded\n\nusername=sir&password=123456\n```\n3.Content-Type: multipart/form-data; boundary=—-RANDOM_jDMUxq4Ot5 (表单有文件上传时的格式)\n\n  - **Accpet**:<br />\n资源可以有多种表示方式，如json、xml、pdf、excel等等，客户端可以指定自己期望的格式，通常有两种方式：<br />\n1.http header头重的Accpet字段：\n\n```\nAccept:application/xml;q=0.6,application/atom+xml;q=1.0 \n\n  // q 为格式的偏好程度\n```\n2.url中加文件后缀，如：test.html\n\n  - Cookie<br />\n请求头由cookie字段控制：\n```\nCookie:Hm_lvt_3d8e7fc0de8a2a75f2ca3bfe128e6391=1489670554,1490097787,1490798805,1490975802;Hm_lpvt_3d8e7fc0de8a2a75f2ca3bfe128e6391=1490975802; Hm_lvt_079fac161efc4b2a6f31e80064f14e82=1489636957,1490097787,1490798805,1490975802; Hm_lpvt_079fac161efc4b2a6f31e80064f14e82=1490975802\n```\n\n- **body**<br />\n在请求的正文中使用JSON格式的数据，与返回的格式相对应。\n\n\n<a name=\"d2a6206b\"></a>\n#### 3. response\n\n- **状态码**\n\n200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。\n\n201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。\n\n202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）\n\n204 NO CONTENT - [DELETE]：用户删除数据成功。\n\n400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。\n\n401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。\n\n403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。\n\n404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。\n\n406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。\n\n410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。\n\n422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。\n\n500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功\n\n503 service unavaliable - [*]：由容器抛出，自己的代码不要抛这个异常\n\n```\n* **header**\n```\n\nCache-Control:max-age=2592000<br />\nContent-Encoding:gzip<br />\nContent-Length:2723<br />\nContent-Type:image/gif<br />\nDate:Fri, 31 Mar 2017 08:33:05 GMT<br />\nExpires:Sun, 30 Apr 2017 08:33:05 GMT<br />\nLast-Modified:Fri, 31 Mar 2017 02:00:00 GMT<br />\netag:\"58dac650-14168\"<br />\nexpires:Wed, 28 Mar 2018 20:28:15 GMT<br />\nServer:Qnginx/1.3.2<br />\nTiming-Allow-Origin:*\n\n```\n* **Content-Type**\n```\n\nContent-Type:application/javascript; charset=utf-8\n\ncontent-type:text/html; charset=GB18030\n\n```\n设置返回的文件类型。\n\n* **缓存(一般不在业务层处理)**\n 返回的头部一般由3个字段控制：\n```\n\ncache-control:max-age=691200\n\nlast-modified:Sat, 07 Mar 2015 16:28:18 GMT\n\netag:W/\"fbbd4924d5b6836c48ac099e397dbf7a\"\n\n```\n* **Set-Cookie**\n```\n\nset-cookie:username=848760247&848760247; Domain=mail.qq.com; Path=/\n\nset-cookie:tinfo=1490975913.0000*; Domain=mail.qq.com; Path=/\n\nset-cookie:wimrefreshrun=0&; Domain=mail.qq.com; Path=/\n\n```\nSet-Cookie字段控制返回的cookie信息。\n\n* **body**\n返回的数据一般为json格式。\n\n\n* **json规范**\n  * 基本结构\n      * 状态：\n      ```\n      {\n          \"status\":\"success\",\n      }\n      ```\n      返回的json中含有判断状态的标识。\n\n      * 提示：\n      返回的数据中应有请求的提示信息字段。\n       ```\n      {\n          \"msg\":\"your password is not ture\",\n      }\n      ```\n\n      * data（如分页设计：page，pageSize，total, totalPage）\n      ```\n      {\n          \"multipart-page\":{\n            \"page\":\"1\",\n            \"pagesize\":\"10\",\n            \"total\":\"8\",\n            \"totalpage\":\"2\"\n          }\n      }\n      ```\n  * 深度限制：\n  数据的深度层级一般在4-6层之间。\n  \n#### 4. 字段规范\n\n* **时间**\n返回的时间一般都是UTC格式，ISO8601格式的数据，如：\n```\n\n{<br />\n\"create-time\":\"2017-3-31T12:00:00Z\"<br />\n}\n\n```\n* **编码**\n\n字段中的特殊字符，html标签都应转化为实体字符。\n\n* **超链接**\n\n最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。\n\n#### 5. 错误处理\n 1.不要发生了错误但给2xx响应，客户端可能会缓存成功的http请求；\n 2.正确设置http状态码，不要自定义；\n 3.Response body 提供错误的代码（日志/问题追查）和错误的描述文本（展示给用户）。\n\n* **业务型异常**\n>由自己的业务代码抛出，表示一个用例的前置条件不满足、业务规则冲突等，比如参数校验不通过、权限校验失败\n业务类异常必须提供2种信息：\n * 如果抛出该类异常，HTTP 响应状态码应该设成什么；\n * 异常的文本描述\n* **非业务型**\n>表示不在预期内的问题，通常由类库、框架抛出，或由于自己的代码逻辑错误导致，比如数据库连接失败、空指针异常、除0错误等等\n\n在Controller层使用统一的异常拦截器：\n\n 1.设置 HTTP 响应状态码：对业务类异常，用它指定的 HTTP code；对非业务类异常，统一500；\n\n 2.Response Body 的错误码：异常类名\n\n 3.Response Body 的错误描述：对业务类异常，用它指定的错误文本；对非业务类异常，线上可以统一文案如“服务器端错误，请稍后再试”，开发或测试环境中用异常的 stacktrace，服务器端提供该行为的开关\n\n#### 6. 安全\n API的身份认证应该使用OAuth 2.0框架。\n\n参考了几篇文章之后，自己的总结，可能不是很完善。\n```\n\n",
    "body_draft": "",
    "body_html": "<p>date: 2017-03-30 00:41:45</p><p>categories: ['前端']</p><p>tags: ['RESTfulAPI','后端']</p><hr /><p><br /></p><p><span>\n    <a>\n      \n    </a>\n  \n    <a>\n      \n    </a>\n  </span>API(Application Programming Interface,应用程序编程接口)是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。简单的说，API就是通过某一预先定义的渠道读/写数据的方式。由于技术的发展，前后分离模式已经成为主流，且前端设备层出不穷，于是为统一前后端通信的机制，WEB API应运而生。下面我就从发起一个请求到返回数据的过程中，聊一聊API的设计规范。</p><p>&lt;!-- more --&gt;</p><h2 id=\"12ccbaff\">一. 初识 RESTful API</h2><p><br /></p><h4 id=\"e6240c27\">1. RESTful架构的前世今生：</h4><p><br /></p><p>REST(Representational State Transfer,表层状态转化)是由是Roy Thomas Fielding(HTTP协议（1.0版和1.1版）的主要设计者、Apache服务器软件的作者之一、Apache基金会的第一任主席)在他2000年的博士论文中提出的，而如果一个架构符合REST原则，那就称之为RESTful架构。</p><p><br /></p><h4 id=\"cf100273\">2. 浅析RESTful架构（资源表现层状态转化）：</h4><p><br /></p><ul><li><p>资源：资源即网络上的一个实体，如文本、图片、歌曲，甚至一种服务，也可以称之为资源，而URI(统一资源标识符)是指向某一种资源的唯一标识，我们上网，就是通过URI与某些资源进行互动的过程。</p></li></ul><ul><li><p>表现层：“资源”是一种信息实体，它可以有多种外在表现形式(html、xml、json、jpg等)。我们把“资源”具体呈现出来的形式，叫做它的“表现层”（Representation）。URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的“.html”后缀名是不必要的，因为这个后缀名表示格式，属于&quot;表现层&quot;范畴，而URI应该只代表&quot;资源&quot;的位置。HTTP请求的头信息中ccept和Content-Type字段用于对“表现层”的描述。</p></li></ul><ul><li><p>状态转化：互联网通信协议HTTP协议是一个无状态协议,状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生“状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是“表现层状态转化”。客户端用到的手段，就是HTTP协议里面，四个表示操作方式的动词：GET(获取资源)、POST(新建/更新资源)、PUT(更新资源)、DELETE(删除资源)。</p></li></ul><p><br /></p><h4 id=\"3739b886\">3. 总结：</h4><p><br /></p><ul><li>一个URI代表一种资源.</li></ul><ul><li>客户端和服务器之间，传递这种资源的某种表现层.</li></ul><ul><li>客户端通过四个HTTP动词，对服务器端资源进行操作，实现&quot;表现层状态转化&quot;.</li></ul><p><br /></p><h2 id=\"0bcc7786\">二. RESTful API的设计规范</h2><p><br /></p><h4 id=\"d84de8d5\">1. URI</h4><p><br /></p><ul><li><p><strong>协议</strong>：</p><p>API与用户的通信协议应为：HTTPS（以安全为目标的HTTP通道，即HTTP下加入SSL层，用于加密和身份验证。）</p></li></ul><ul><li><p><strong>域名</strong>：</p><p>应将API尽量放入专用域名之下：</p></li></ul><p><br /></p><pre><code>https://api.youwebsite.com</code></pre><p><br /></p><p>若只是简单的API且不会继续扩展，可放入主域名之下：</p><p><br /></p><pre><code>https://youwebsite.com/api/</code></pre><p><br /></p><ul><li><p><strong>路径</strong>：</p><p>路径是API中的具体网址，在RESTful架构中，每一个网址代表一种资源，所以URL中不能有动词，只能有名词，而且所有的名词一般与数据库中的表名相对应，数据库中每个表都是一种资源的集合，所以API中的名词应该使用负数，如：</p><pre><code>https://api.youwebsite.com/v1/bookracks    //代表书架的集合\n\nhttps://api.youwebsite.com/v1/bookracks/category   //代表书架的分类\n\nhttps://api.youwebsite.com/v1/manager  //代表书架的管理员</code></pre></li></ul><ul><li><p><strong>复杂查询</strong>:</p></li></ul><p><br /></p><table class=\"lake-table\" style=\"width: 721px;\"><colgroup><col width=\"240\"></col><col width=\"240\"></col><col width=\"240\"></col></colgroup><tbody><tr><td></td><td>示例</td><td>备注</td></tr><tr><td>过滤条件</td><td>?type=1&amp;num=6</td><td>允许一定冗余，如/books/1可以写成/books?id=1</td></tr><tr><td>排序</td><td>?sort=page,desc</td><td></td></tr><tr><td>投影</td><td>?userinfo=id,name,email</td><td></td></tr><tr><td>分页</td><td>?limit=10&amp;offset=3</td><td></td></tr></tbody></table><p><br /></p><ul><li><strong>Bookmarker</strong>:<br />\n经常使用的、复杂的查询标签化，降低维护成本。如：</li></ul><p><br /></p><pre><code>/trades?status=closed&amp;sort=created,desc\n\n可以写成：\n\nGET /trades/recently-closed</code></pre><p><br /></p><h4 id=\"bcb0194d\">2. request</h4><p><br /></p><ul><li><p><strong>HTTP方法</strong>:</p><p>常用的动词：</p></li></ul><ul data-lake-indent=\"1\"><li><p>GET(select): 从服务器取出资源</p></li></ul><ul data-lake-indent=\"1\"><li><p>POST(create): 在服务器创建一个资源</p></li></ul><ul data-lake-indent=\"1\"><li><p>PUT(update): 在服务器更新资源（客户提供改变后的完整资源，如改变用户的信息）</p></li></ul><ul data-lake-indent=\"1\"><li><p>PATCH(update): 在服务器更新资源（客户提供改变的属性，如修改用户的状态）</p></li></ul><ul data-lake-indent=\"1\"><li><p>DELETE(delete): 从服务器删除资源</p></li></ul><p>不常用的动词：</p><ul data-lake-indent=\"1\"><li><p>HEAD: 获取资源的元数据</p></li></ul><ul data-lake-indent=\"1\"><li><p>OPTIONS: 获取信息，关于资源的哪些属性客户是可以改变的</p></li></ul><ul><li><p><strong>header</strong></p></li></ul><ul data-lake-indent=\"1\"><li><p>Content-Type：<br />\n1.Content-Type:application/json</p><pre><code>POST /v1/animal HTTP/1.1\nHost: api.youwebsite.com\nAccept: application/json\nContent-Type: application/json\nContent-Length: 24\n\n{   \n  &quot;name&quot;: &quot;Sir H&quot;,\n  &quot;age&quot;: &quot;12&quot;\n}</code></pre><p>2.Content-Type:application/x-www-form-urlencoded</p><pre><code>POST /login HTTP/1.1\nHost: example.com\nContent-Length: 31\nAccept: text/html\nContent-Type: application/x-www-form-urlencoded\n\nusername=sir&amp;password=123456</code></pre><p>3.Content-Type: multipart/form-data; boundary=—-RANDOM_jDMUxq4Ot5 (表单有文件上传时的格式)</p></li></ul><ul data-lake-indent=\"1\"><li><p><strong>Accpet</strong>:<br />\n资源可以有多种表示方式，如json、xml、pdf、excel等等，客户端可以指定自己期望的格式，通常有两种方式：<br />\n1.http header头重的Accpet字段：</p></li></ul><pre><code>Accept:application/xml;q=0.6,application/atom+xml;q=1.0 \n\n  // q 为格式的偏好程度</code></pre><p>2.url中加文件后缀，如：test.html</p><ul data-lake-indent=\"1\"><li>Cookie<br />\n请求头由cookie字段控制：</li></ul><pre><code>Cookie:Hm_lvt_3d8e7fc0de8a2a75f2ca3bfe128e6391=1489670554,1490097787,1490798805,1490975802;Hm_lpvt_3d8e7fc0de8a2a75f2ca3bfe128e6391=1490975802; Hm_lvt_079fac161efc4b2a6f31e80064f14e82=1489636957,1490097787,1490798805,1490975802; Hm_lpvt_079fac161efc4b2a6f31e80064f14e82=1490975802</code></pre><ul><li><p><strong>body</strong><br />\n在请求的正文中使用JSON格式的数据，与返回的格式相对应。</p></li></ul><p><br /></p><h4 id=\"d2a6206b\">3. response</h4><p><br /></p><ul><li><strong>状态码</strong></li></ul><p><br /></p><p>200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</p><p><br /></p><p>201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</p><p><br /></p><p>202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</p><p><br /></p><p>204 NO CONTENT - [DELETE]：用户删除数据成功。</p><p><br /></p><p>400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</p><p><br /></p><p>401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</p><p><br /></p><p>403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</p><p><br /></p><p>404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</p><p><br /></p><p>406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</p><p><br /></p><p>410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</p><p><br /></p><p>422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</p><p><br /></p><p>500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功</p><p><br /></p><p>503 service unavaliable - [*]：由容器抛出，自己的代码不要抛这个异常</p><p><br /></p><pre><code>* **header**</code></pre><p><br /></p><p>Cache-Control:max-age=2592000<br />\nContent-Encoding:gzip<br />\nContent-Length:2723<br />\nContent-Type:image/gif<br />\nDate:Fri, 31 Mar 2017 08:33:05 GMT<br />\nExpires:Sun, 30 Apr 2017 08:33:05 GMT<br />\nLast-Modified:Fri, 31 Mar 2017 02:00:00 GMT<br />\netag:&quot;58dac650-14168&quot;<br />\nexpires:Wed, 28 Mar 2018 20:28:15 GMT<br />\nServer:Qnginx/1.3.2<br />\nTiming-Allow-Origin:*</p><p><br /></p><pre><code>* **Content-Type**</code></pre><p><br /></p><p>Content-Type:application/javascript; charset=utf-8</p><p><br /></p><p>content-type:text/html; charset=GB18030</p><p><br /></p><pre><code>设置返回的文件类型。\n\n* **缓存(一般不在业务层处理)**\n 返回的头部一般由3个字段控制：</code></pre><p><br /></p><p>cache-control:max-age=691200</p><p><br /></p><p>last-modified:Sat, 07 Mar 2015 16:28:18 GMT</p><p><br /></p><p>etag:W/&quot;fbbd4924d5b6836c48ac099e397dbf7a&quot;</p><p><br /></p><pre><code>* **Set-Cookie**</code></pre><p><br /></p><p>set-cookie:username=848760247&amp;848760247; Domain=mail.qq.com; Path=/</p><p><br /></p><p>set-cookie:tinfo=1490975913.0000*; Domain=mail.qq.com; Path=/</p><p><br /></p><p>set-cookie:wimrefreshrun=0&amp;; Domain=mail.qq.com; Path=/</p><p><br /></p><pre><code>Set-Cookie字段控制返回的cookie信息。\n\n* **body**\n返回的数据一般为json格式。\n\n\n* **json规范**\n  * 基本结构\n      * 状态：\n      ```\n      {\n          &quot;status&quot;:&quot;success&quot;,\n      }\n      ```\n      返回的json中含有判断状态的标识。\n\n      * 提示：\n      返回的数据中应有请求的提示信息字段。\n       ```\n      {\n          &quot;msg&quot;:&quot;your password is not ture&quot;,\n      }\n      ```\n\n      * data（如分页设计：page，pageSize，total, totalPage）\n      ```\n      {\n          &quot;multipart-page&quot;:{\n            &quot;page&quot;:&quot;1&quot;,\n            &quot;pagesize&quot;:&quot;10&quot;,\n            &quot;total&quot;:&quot;8&quot;,\n            &quot;totalpage&quot;:&quot;2&quot;\n          }\n      }\n      ```\n  * 深度限制：\n  数据的深度层级一般在4-6层之间。\n  \n#### 4. 字段规范\n\n* **时间**\n返回的时间一般都是UTC格式，ISO8601格式的数据，如：</code></pre><p><br /></p><p>{<br />\n&quot;create-time&quot;:&quot;2017-3-31T12:00:00Z&quot;<br />\n}</p><p><br /></p><pre><code>* **编码**\n\n字段中的特殊字符，html标签都应转化为实体字符。\n\n* **超链接**\n\n最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。\n\n#### 5. 错误处理\n 1.不要发生了错误但给2xx响应，客户端可能会缓存成功的http请求；\n 2.正确设置http状态码，不要自定义；\n 3.Response body 提供错误的代码（日志/问题追查）和错误的描述文本（展示给用户）。\n\n* **业务型异常**\n&gt;由自己的业务代码抛出，表示一个用例的前置条件不满足、业务规则冲突等，比如参数校验不通过、权限校验失败\n业务类异常必须提供2种信息：\n * 如果抛出该类异常，HTTP 响应状态码应该设成什么；\n * 异常的文本描述\n* **非业务型**\n&gt;表示不在预期内的问题，通常由类库、框架抛出，或由于自己的代码逻辑错误导致，比如数据库连接失败、空指针异常、除0错误等等\n\n在Controller层使用统一的异常拦截器：\n\n 1.设置 HTTP 响应状态码：对业务类异常，用它指定的 HTTP code；对非业务类异常，统一500；\n\n 2.Response Body 的错误码：异常类名\n\n 3.Response Body 的错误描述：对业务类异常，用它指定的错误文本；对非业务类异常，线上可以统一文案如“服务器端错误，请稍后再试”，开发或测试环境中用异常的 stacktrace，服务器端提供该行为的开关\n\n#### 6. 安全\n API的身份认证应该使用OAuth 2.0框架。\n\n参考了几篇文章之后，自己的总结，可能不是很完善。</code></pre><p><br /></p>",
    "body_lake": "<!doctype lake><p>date: 2017-03-30 00:41:45</p><p>categories: ['前端']</p><p>tags: ['RESTful<cursor />API','后端']</p><card type=\"block\" name=\"hr\"></card><p><br /></p><p><span>\n    <a>\n      \n    </a>\n  \n    <a>\n      \n    </a>\n  </span>API(Application Programming Interface,应用程序编程接口)是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。简单的说，API就是通过某一预先定义的渠道读/写数据的方式。由于技术的发展，前后分离模式已经成为主流，且前端设备层出不穷，于是为统一前后端通信的机制，WEB API应运而生。下面我就从发起一个请求到返回数据的过程中，聊一聊API的设计规范。</p><p>&lt;!-- more --&gt;</p><h2 id=\"12ccbaff\">一. 初识 RESTful API</h2><p><br /></p><h4 id=\"e6240c27\">1. RESTful架构的前世今生：</h4><p><br /></p><p>REST(Representational State Transfer,表层状态转化)是由是Roy Thomas Fielding(HTTP协议（1.0版和1.1版）的主要设计者、Apache服务器软件的作者之一、Apache基金会的第一任主席)在他2000年的博士论文中提出的，而如果一个架构符合REST原则，那就称之为RESTful架构。</p><p><br /></p><h4 id=\"cf100273\">2. 浅析RESTful架构（资源表现层状态转化）：</h4><p><br /></p><ul><li><p>资源：资源即网络上的一个实体，如文本、图片、歌曲，甚至一种服务，也可以称之为资源，而URI(统一资源标识符)是指向某一种资源的唯一标识，我们上网，就是通过URI与某些资源进行互动的过程。</p></li></ul><ul><li><p>表现层：“资源”是一种信息实体，它可以有多种外在表现形式(html、xml、json、jpg等)。我们把“资源”具体呈现出来的形式，叫做它的“表现层”（Representation）。URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的“.html”后缀名是不必要的，因为这个后缀名表示格式，属于&quot;表现层&quot;范畴，而URI应该只代表&quot;资源&quot;的位置。HTTP请求的头信息中ccept和Content-Type字段用于对“表现层”的描述。</p></li></ul><ul><li><p>状态转化：互联网通信协议HTTP协议是一个无状态协议,状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生“状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是“表现层状态转化”。客户端用到的手段，就是HTTP协议里面，四个表示操作方式的动词：GET(获取资源)、POST(新建/更新资源)、PUT(更新资源)、DELETE(删除资源)。</p></li></ul><p><br /></p><h4 id=\"3739b886\">3. 总结：</h4><p><br /></p><ul><li>一个URI代表一种资源.</li></ul><ul><li>客户端和服务器之间，传递这种资源的某种表现层.</li></ul><ul><li>客户端通过四个HTTP动词，对服务器端资源进行操作，实现&quot;表现层状态转化&quot;.</li></ul><p><br /></p><h2 id=\"0bcc7786\">二. RESTful API的设计规范</h2><p><br /></p><h4 id=\"d84de8d5\">1. URI</h4><p><br /></p><ul><li><p><strong>协议</strong>：</p><p>API与用户的通信协议应为：HTTPS（以安全为目标的HTTP通道，即HTTP下加入SSL层，用于加密和身份验证。）</p></li></ul><ul><li><p><strong>域名</strong>：</p><p>应将API尽量放入专用域名之下：</p></li></ul><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22code%22%3A%22https%3A%2F%2Fapi.youwebsite.com%22%7D\"></card><p><br /></p><p>若只是简单的API且不会继续扩展，可放入主域名之下：</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22code%22%3A%22https%3A%2F%2Fyouwebsite.com%2Fapi%2F%22%7D\"></card><p><br /></p><ul><li><p><strong>路径</strong>：</p><p>路径是API中的具体网址，在RESTful架构中，每一个网址代表一种资源，所以URL中不能有动词，只能有名词，而且所有的名词一般与数据库中的表名相对应，数据库中每个表都是一种资源的集合，所以API中的名词应该使用负数，如：</p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22code%22%3A%22https%3A%2F%2Fapi.youwebsite.com%2Fv1%2Fbookracks%20%20%20%20%2F%2F%E4%BB%A3%E8%A1%A8%E4%B9%A6%E6%9E%B6%E7%9A%84%E9%9B%86%E5%90%88%5Cn%5Cnhttps%3A%2F%2Fapi.youwebsite.com%2Fv1%2Fbookracks%2Fcategory%20%20%20%2F%2F%E4%BB%A3%E8%A1%A8%E4%B9%A6%E6%9E%B6%E7%9A%84%E5%88%86%E7%B1%BB%5Cn%5Cnhttps%3A%2F%2Fapi.youwebsite.com%2Fv1%2Fmanager%20%20%2F%2F%E4%BB%A3%E8%A1%A8%E4%B9%A6%E6%9E%B6%E7%9A%84%E7%AE%A1%E7%90%86%E5%91%98%22%7D\"></card></li></ul><ul><li><p><strong>复杂查询</strong>:</p></li></ul><p><br /></p><card type=\"block\" name=\"table\" value=\"data:%7B%22rows%22%3A5%2C%22cols%22%3A3%2C%22html%22%3A%22%3Ctable%20class%3D%5C%22lake-table%5C%22%20style%3D%5C%22width%3A%20721px%3B%5C%22%3E%3Ccolgroup%3E%3Ccol%20span%3D%5C%221%5C%22%20width%3D%5C%22240%5C%22%20%2F%3E%3Ccol%20span%3D%5C%221%5C%22%20width%3D%5C%22240%5C%22%20%2F%3E%3Ccol%20span%3D%5C%221%5C%22%20width%3D%5C%22240%5C%22%20%2F%3E%3C%2Fcolgroup%3E%3Ctbody%3E%3Ctr%20style%3D%5C%22height%3A%2033px%3B%5C%22%3E%3Ctd%3E%3C%2Ftd%3E%3Ctd%3E%E7%A4%BA%E4%BE%8B%3C%2Ftd%3E%3Ctd%3E%E5%A4%87%E6%B3%A8%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20style%3D%5C%22height%3A%2033px%3B%5C%22%3E%3Ctd%3E%E8%BF%87%E6%BB%A4%E6%9D%A1%E4%BB%B6%3C%2Ftd%3E%3Ctd%3E%3Ftype%3D1%26amp%3Bnum%3D6%3C%2Ftd%3E%3Ctd%3E%E5%85%81%E8%AE%B8%E4%B8%80%E5%AE%9A%E5%86%97%E4%BD%99%EF%BC%8C%E5%A6%82%2Fbooks%2F1%E5%8F%AF%E4%BB%A5%E5%86%99%E6%88%90%2Fbooks%3Fid%3D1%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20style%3D%5C%22height%3A%2033px%3B%5C%22%3E%3Ctd%3E%E6%8E%92%E5%BA%8F%3C%2Ftd%3E%3Ctd%3E%3Fsort%3Dpage%2Cdesc%3C%2Ftd%3E%3Ctd%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20style%3D%5C%22height%3A%2033px%3B%5C%22%3E%3Ctd%3E%E6%8A%95%E5%BD%B1%3C%2Ftd%3E%3Ctd%3E%3Fuserinfo%3Did%2Cname%2Cemail%3C%2Ftd%3E%3Ctd%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20style%3D%5C%22height%3A%2033px%3B%5C%22%3E%3Ctd%3E%E5%88%86%E9%A1%B5%3C%2Ftd%3E%3Ctd%3E%3Flimit%3D10%26amp%3Boffset%3D3%3C%2Ftd%3E%3Ctd%3E%3C%2Ftd%3E%3C%2Ftr%3E%3C%2Ftbody%3E%3C%2Ftable%3E%22%7D\"></card><p><br /></p><ul><li><strong>Bookmarker</strong>:<br />\n经常使用的、复杂的查询标签化，降低维护成本。如：</li></ul><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22code%22%3A%22%2Ftrades%3Fstatus%3Dclosed%26sort%3Dcreated%2Cdesc%5Cn%5Cn%E5%8F%AF%E4%BB%A5%E5%86%99%E6%88%90%EF%BC%9A%5Cn%5CnGET%20%2Ftrades%2Frecently-closed%22%7D\"></card><p><br /></p><h4 id=\"bcb0194d\">2. request</h4><p><br /></p><ul><li><p><strong>HTTP方法</strong>:</p><p>常用的动词：</p></li></ul><ul data-lake-indent=\"1\"><li><p>GET(select): 从服务器取出资源</p></li></ul><ul data-lake-indent=\"1\"><li><p>POST(create): 在服务器创建一个资源</p></li></ul><ul data-lake-indent=\"1\"><li><p>PUT(update): 在服务器更新资源（客户提供改变后的完整资源，如改变用户的信息）</p></li></ul><ul data-lake-indent=\"1\"><li><p>PATCH(update): 在服务器更新资源（客户提供改变的属性，如修改用户的状态）</p></li></ul><ul data-lake-indent=\"1\"><li><p>DELETE(delete): 从服务器删除资源</p></li></ul><p>不常用的动词：</p><ul data-lake-indent=\"1\"><li><p>HEAD: 获取资源的元数据</p></li></ul><ul data-lake-indent=\"1\"><li><p>OPTIONS: 获取信息，关于资源的哪些属性客户是可以改变的</p></li></ul><ul><li><p><strong>header</strong></p></li></ul><ul data-lake-indent=\"1\"><li><p>Content-Type：<br />\n1.Content-Type:application/json</p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22code%22%3A%22POST%20%2Fv1%2Fanimal%20HTTP%2F1.1%5CnHost%3A%20api.youwebsite.com%5CnAccept%3A%20application%2Fjson%5CnContent-Type%3A%20application%2Fjson%5CnContent-Length%3A%2024%5Cn%5Cn%7B%20%20%20%5Cn%20%20%5C%22name%5C%22%3A%20%5C%22Sir%20H%5C%22%2C%5Cn%20%20%5C%22age%5C%22%3A%20%5C%2212%5C%22%5Cn%7D%22%7D\"></card><p>2.Content-Type:application/x-www-form-urlencoded</p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22code%22%3A%22POST%20%2Flogin%20HTTP%2F1.1%5CnHost%3A%20example.com%5CnContent-Length%3A%2031%5CnAccept%3A%20text%2Fhtml%5CnContent-Type%3A%20application%2Fx-www-form-urlencoded%5Cn%5Cnusername%3Dsir%26password%3D123456%22%7D\"></card><p>3.Content-Type: multipart/form-data; boundary=—-RANDOM_jDMUxq4Ot5 (表单有文件上传时的格式)</p></li></ul><ul data-lake-indent=\"1\"><li><p><strong>Accpet</strong>:<br />\n资源可以有多种表示方式，如json、xml、pdf、excel等等，客户端可以指定自己期望的格式，通常有两种方式：<br />\n1.http header头重的Accpet字段：</p></li></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22code%22%3A%22Accept%3Aapplication%2Fxml%3Bq%3D0.6%2Capplication%2Fatom%2Bxml%3Bq%3D1.0%20%5Cn%5Cn%20%20%2F%2F%20q%20%E4%B8%BA%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%81%8F%E5%A5%BD%E7%A8%8B%E5%BA%A6%22%7D\"></card><p>2.url中加文件后缀，如：test.html</p><ul data-lake-indent=\"1\"><li>Cookie<br />\n请求头由cookie字段控制：</li></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22code%22%3A%22Cookie%3AHm_lvt_3d8e7fc0de8a2a75f2ca3bfe128e6391%3D1489670554%2C1490097787%2C1490798805%2C1490975802%3BHm_lpvt_3d8e7fc0de8a2a75f2ca3bfe128e6391%3D1490975802%3B%20Hm_lvt_079fac161efc4b2a6f31e80064f14e82%3D1489636957%2C1490097787%2C1490798805%2C1490975802%3B%20Hm_lpvt_079fac161efc4b2a6f31e80064f14e82%3D1490975802%22%7D\"></card><ul><li><p><strong>body</strong><br />\n在请求的正文中使用JSON格式的数据，与返回的格式相对应。</p></li></ul><p><br /></p><h4 id=\"d2a6206b\">3. response</h4><p><br /></p><ul><li><strong>状态码</strong><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22code%22%3A%22%22%7D\"></card></li></ul><p><br /></p><p>200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</p><p><br /></p><p>201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</p><p><br /></p><p>202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</p><p><br /></p><p>204 NO CONTENT - [DELETE]：用户删除数据成功。</p><p><br /></p><p>400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</p><p><br /></p><p>401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</p><p><br /></p><p>403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</p><p><br /></p><p>404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</p><p><br /></p><p>406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</p><p><br /></p><p>410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</p><p><br /></p><p>422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</p><p><br /></p><p>500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功</p><p><br /></p><p>503 service unavaliable - [*]：由容器抛出，自己的代码不要抛这个异常</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22code%22%3A%22*%20**header**%22%7D\"></card><p><br /></p><p>Cache-Control:max-age=2592000<br />\nContent-Encoding:gzip<br />\nContent-Length:2723<br />\nContent-Type:image/gif<br />\nDate:Fri, 31 Mar 2017 08:33:05 GMT<br />\nExpires:Sun, 30 Apr 2017 08:33:05 GMT<br />\nLast-Modified:Fri, 31 Mar 2017 02:00:00 GMT<br />\netag:&quot;58dac650-14168&quot;<br />\nexpires:Wed, 28 Mar 2018 20:28:15 GMT<br />\nServer:Qnginx/1.3.2<br />\nTiming-Allow-Origin:*</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22code%22%3A%22*%20**Content-Type**%22%7D\"></card><p><br /></p><p>Content-Type:application/javascript; charset=utf-8</p><p><br /></p><p>content-type:text/html; charset=GB18030</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22code%22%3A%22%E8%AE%BE%E7%BD%AE%E8%BF%94%E5%9B%9E%E7%9A%84%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E3%80%82%5Cn%5Cn*%20**%E7%BC%93%E5%AD%98(%E4%B8%80%E8%88%AC%E4%B8%8D%E5%9C%A8%E4%B8%9A%E5%8A%A1%E5%B1%82%E5%A4%84%E7%90%86)**%5Cn%20%E8%BF%94%E5%9B%9E%E7%9A%84%E5%A4%B4%E9%83%A8%E4%B8%80%E8%88%AC%E7%94%B13%E4%B8%AA%E5%AD%97%E6%AE%B5%E6%8E%A7%E5%88%B6%EF%BC%9A%22%7D\"></card><p><br /></p><p>cache-control:max-age=691200</p><p><br /></p><p>last-modified:Sat, 07 Mar 2015 16:28:18 GMT</p><p><br /></p><p>etag:W/&quot;fbbd4924d5b6836c48ac099e397dbf7a&quot;</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22code%22%3A%22*%20**Set-Cookie**%22%7D\"></card><p><br /></p><p>set-cookie:username=848760247&amp;848760247; Domain=mail.qq.com; Path=/</p><p><br /></p><p>set-cookie:tinfo=1490975913.0000*; Domain=mail.qq.com; Path=/</p><p><br /></p><p>set-cookie:wimrefreshrun=0&amp;; Domain=mail.qq.com; Path=/</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22code%22%3A%22Set-Cookie%E5%AD%97%E6%AE%B5%E6%8E%A7%E5%88%B6%E8%BF%94%E5%9B%9E%E7%9A%84cookie%E4%BF%A1%E6%81%AF%E3%80%82%5Cn%5Cn*%20**body**%5Cn%E8%BF%94%E5%9B%9E%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%88%AC%E4%B8%BAjson%E6%A0%BC%E5%BC%8F%E3%80%82%5Cn%5Cn%5Cn*%20**json%E8%A7%84%E8%8C%83**%5Cn%20%20*%20%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%5Cn%20%20%20%20%20%20*%20%E7%8A%B6%E6%80%81%EF%BC%9A%5Cn%20%20%20%20%20%20%60%60%60%5Cn%20%20%20%20%20%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%5C%22status%5C%22%3A%5C%22success%5C%22%2C%5Cn%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%60%60%60%5Cn%20%20%20%20%20%20%E8%BF%94%E5%9B%9E%E7%9A%84json%E4%B8%AD%E5%90%AB%E6%9C%89%E5%88%A4%E6%96%AD%E7%8A%B6%E6%80%81%E7%9A%84%E6%A0%87%E8%AF%86%E3%80%82%5Cn%5Cn%20%20%20%20%20%20*%20%E6%8F%90%E7%A4%BA%EF%BC%9A%5Cn%20%20%20%20%20%20%E8%BF%94%E5%9B%9E%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BA%94%E6%9C%89%E8%AF%B7%E6%B1%82%E7%9A%84%E6%8F%90%E7%A4%BA%E4%BF%A1%E6%81%AF%E5%AD%97%E6%AE%B5%E3%80%82%5Cn%20%20%20%20%20%20%20%60%60%60%5Cn%20%20%20%20%20%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%5C%22msg%5C%22%3A%5C%22your%20password%20is%20not%20ture%5C%22%2C%5Cn%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%60%60%60%5Cn%5Cn%20%20%20%20%20%20*%20data%EF%BC%88%E5%A6%82%E5%88%86%E9%A1%B5%E8%AE%BE%E8%AE%A1%EF%BC%9Apage%EF%BC%8CpageSize%EF%BC%8Ctotal%2C%20totalPage%EF%BC%89%5Cn%20%20%20%20%20%20%60%60%60%5Cn%20%20%20%20%20%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%5C%22multipart-page%5C%22%3A%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%5C%22page%5C%22%3A%5C%221%5C%22%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%5C%22pagesize%5C%22%3A%5C%2210%5C%22%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%5C%22total%5C%22%3A%5C%228%5C%22%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%5C%22totalpage%5C%22%3A%5C%222%5C%22%5Cn%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%60%60%60%5Cn%20%20*%20%E6%B7%B1%E5%BA%A6%E9%99%90%E5%88%B6%EF%BC%9A%5Cn%20%20%E6%95%B0%E6%8D%AE%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%B1%82%E7%BA%A7%E4%B8%80%E8%88%AC%E5%9C%A84-6%E5%B1%82%E4%B9%8B%E9%97%B4%E3%80%82%5Cn%20%20%5Cn%23%23%23%23%204.%20%E5%AD%97%E6%AE%B5%E8%A7%84%E8%8C%83%5Cn%5Cn*%20**%E6%97%B6%E9%97%B4**%5Cn%E8%BF%94%E5%9B%9E%E7%9A%84%E6%97%B6%E9%97%B4%E4%B8%80%E8%88%AC%E9%83%BD%E6%98%AFUTC%E6%A0%BC%E5%BC%8F%EF%BC%8CISO8601%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%A6%82%EF%BC%9A%22%7D\"></card><p><br /></p><p>{<br />\n&quot;create-time&quot;:&quot;2017-3-31T12:00:00Z&quot;<br />\n}</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22code%22%3A%22*%20**%E7%BC%96%E7%A0%81**%5Cn%5Cn%E5%AD%97%E6%AE%B5%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%EF%BC%8Chtml%E6%A0%87%E7%AD%BE%E9%83%BD%E5%BA%94%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%AE%9E%E4%BD%93%E5%AD%97%E7%AC%A6%E3%80%82%5Cn%5Cn*%20**%E8%B6%85%E9%93%BE%E6%8E%A5**%5Cn%5Cn%E6%9C%80%E5%A5%BD%E5%81%9A%E5%88%B0Hypermedia%EF%BC%8C%E5%8D%B3%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E4%B8%AD%E6%8F%90%E4%BE%9B%E9%93%BE%E6%8E%A5%EF%BC%8C%E8%BF%9E%E5%90%91%E5%85%B6%E4%BB%96API%E6%96%B9%E6%B3%95%EF%BC%8C%E4%BD%BF%E5%BE%97%E7%94%A8%E6%88%B7%E4%B8%8D%E6%9F%A5%E6%96%87%E6%A1%A3%EF%BC%8C%E4%B9%9F%E7%9F%A5%E9%81%93%E4%B8%8B%E4%B8%80%E6%AD%A5%E5%BA%94%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88%E3%80%82%5Cn%5Cn%23%23%23%23%205.%20%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%5Cn%201.%E4%B8%8D%E8%A6%81%E5%8F%91%E7%94%9F%E4%BA%86%E9%94%99%E8%AF%AF%E4%BD%86%E7%BB%992xx%E5%93%8D%E5%BA%94%EF%BC%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%AF%E8%83%BD%E4%BC%9A%E7%BC%93%E5%AD%98%E6%88%90%E5%8A%9F%E7%9A%84http%E8%AF%B7%E6%B1%82%EF%BC%9B%5Cn%202.%E6%AD%A3%E7%A1%AE%E8%AE%BE%E7%BD%AEhttp%E7%8A%B6%E6%80%81%E7%A0%81%EF%BC%8C%E4%B8%8D%E8%A6%81%E8%87%AA%E5%AE%9A%E4%B9%89%EF%BC%9B%5Cn%203.Response%20body%20%E6%8F%90%E4%BE%9B%E9%94%99%E8%AF%AF%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%88%E6%97%A5%E5%BF%97%2F%E9%97%AE%E9%A2%98%E8%BF%BD%E6%9F%A5%EF%BC%89%E5%92%8C%E9%94%99%E8%AF%AF%E7%9A%84%E6%8F%8F%E8%BF%B0%E6%96%87%E6%9C%AC%EF%BC%88%E5%B1%95%E7%A4%BA%E7%BB%99%E7%94%A8%E6%88%B7%EF%BC%89%E3%80%82%5Cn%5Cn*%20**%E4%B8%9A%E5%8A%A1%E5%9E%8B%E5%BC%82%E5%B8%B8**%5Cn%3E%E7%94%B1%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81%E6%8A%9B%E5%87%BA%EF%BC%8C%E8%A1%A8%E7%A4%BA%E4%B8%80%E4%B8%AA%E7%94%A8%E4%BE%8B%E7%9A%84%E5%89%8D%E7%BD%AE%E6%9D%A1%E4%BB%B6%E4%B8%8D%E6%BB%A1%E8%B6%B3%E3%80%81%E4%B8%9A%E5%8A%A1%E8%A7%84%E5%88%99%E5%86%B2%E7%AA%81%E7%AD%89%EF%BC%8C%E6%AF%94%E5%A6%82%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C%E4%B8%8D%E9%80%9A%E8%BF%87%E3%80%81%E6%9D%83%E9%99%90%E6%A0%A1%E9%AA%8C%E5%A4%B1%E8%B4%A5%5Cn%E4%B8%9A%E5%8A%A1%E7%B1%BB%E5%BC%82%E5%B8%B8%E5%BF%85%E9%A1%BB%E6%8F%90%E4%BE%9B2%E7%A7%8D%E4%BF%A1%E6%81%AF%EF%BC%9A%5Cn%20*%20%E5%A6%82%E6%9E%9C%E6%8A%9B%E5%87%BA%E8%AF%A5%E7%B1%BB%E5%BC%82%E5%B8%B8%EF%BC%8CHTTP%20%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81%E5%BA%94%E8%AF%A5%E8%AE%BE%E6%88%90%E4%BB%80%E4%B9%88%EF%BC%9B%5Cn%20*%20%E5%BC%82%E5%B8%B8%E7%9A%84%E6%96%87%E6%9C%AC%E6%8F%8F%E8%BF%B0%5Cn*%20**%E9%9D%9E%E4%B8%9A%E5%8A%A1%E5%9E%8B**%5Cn%3E%E8%A1%A8%E7%A4%BA%E4%B8%8D%E5%9C%A8%E9%A2%84%E6%9C%9F%E5%86%85%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E9%80%9A%E5%B8%B8%E7%94%B1%E7%B1%BB%E5%BA%93%E3%80%81%E6%A1%86%E6%9E%B6%E6%8A%9B%E5%87%BA%EF%BC%8C%E6%88%96%E7%94%B1%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91%E9%94%99%E8%AF%AF%E5%AF%BC%E8%87%B4%EF%BC%8C%E6%AF%94%E5%A6%82%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E5%A4%B1%E8%B4%A5%E3%80%81%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8%E3%80%81%E9%99%A40%E9%94%99%E8%AF%AF%E7%AD%89%E7%AD%89%5Cn%5Cn%E5%9C%A8Controller%E5%B1%82%E4%BD%BF%E7%94%A8%E7%BB%9F%E4%B8%80%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%9A%5Cn%5Cn%201.%E8%AE%BE%E7%BD%AE%20HTTP%20%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81%EF%BC%9A%E5%AF%B9%E4%B8%9A%E5%8A%A1%E7%B1%BB%E5%BC%82%E5%B8%B8%EF%BC%8C%E7%94%A8%E5%AE%83%E6%8C%87%E5%AE%9A%E7%9A%84%20HTTP%20code%EF%BC%9B%E5%AF%B9%E9%9D%9E%E4%B8%9A%E5%8A%A1%E7%B1%BB%E5%BC%82%E5%B8%B8%EF%BC%8C%E7%BB%9F%E4%B8%80500%EF%BC%9B%5Cn%5Cn%202.Response%20Body%20%E7%9A%84%E9%94%99%E8%AF%AF%E7%A0%81%EF%BC%9A%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%90%8D%5Cn%5Cn%203.Response%20Body%20%E7%9A%84%E9%94%99%E8%AF%AF%E6%8F%8F%E8%BF%B0%EF%BC%9A%E5%AF%B9%E4%B8%9A%E5%8A%A1%E7%B1%BB%E5%BC%82%E5%B8%B8%EF%BC%8C%E7%94%A8%E5%AE%83%E6%8C%87%E5%AE%9A%E7%9A%84%E9%94%99%E8%AF%AF%E6%96%87%E6%9C%AC%EF%BC%9B%E5%AF%B9%E9%9D%9E%E4%B8%9A%E5%8A%A1%E7%B1%BB%E5%BC%82%E5%B8%B8%EF%BC%8C%E7%BA%BF%E4%B8%8A%E5%8F%AF%E4%BB%A5%E7%BB%9F%E4%B8%80%E6%96%87%E6%A1%88%E5%A6%82%E2%80%9C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E9%94%99%E8%AF%AF%EF%BC%8C%E8%AF%B7%E7%A8%8D%E5%90%8E%E5%86%8D%E8%AF%95%E2%80%9D%EF%BC%8C%E5%BC%80%E5%8F%91%E6%88%96%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%94%A8%E5%BC%82%E5%B8%B8%E7%9A%84%20stacktrace%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%8F%90%E4%BE%9B%E8%AF%A5%E8%A1%8C%E4%B8%BA%E7%9A%84%E5%BC%80%E5%85%B3%5Cn%5Cn%23%23%23%23%206.%20%E5%AE%89%E5%85%A8%5Cn%20API%E7%9A%84%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8OAuth%202.0%E6%A1%86%E6%9E%B6%E3%80%82%5Cn%5Cn%E5%8F%82%E8%80%83%E4%BA%86%E5%87%A0%E7%AF%87%E6%96%87%E7%AB%A0%E4%B9%8B%E5%90%8E%EF%BC%8C%E8%87%AA%E5%B7%B1%E7%9A%84%E6%80%BB%E7%BB%93%EF%BC%8C%E5%8F%AF%E8%83%BD%E4%B8%8D%E6%98%AF%E5%BE%88%E5%AE%8C%E5%96%84%E3%80%82%22%7D\"></card><p><br /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-01-14T03:00:57.000Z",
    "deleted_at": null,
    "created_at": "2019-01-12T03:38:36.000Z",
    "updated_at": "2019-01-14T03:00:57.000Z",
    "published_at": "2019-01-14T03:00:57.000Z",
    "first_published_at": "2019-01-12T03:39:33.000Z",
    "word_count": 2522,
    "cover": null,
    "description": "date: 2017-03-30 00:41:45categories: ['前端']tags: ['RESTfulAPI','后端']                                        API(Application Programming Interface,应...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1138507,
    "slug": "zh2pzr",
    "title": "cnodejs.org 网站首页分析",
    "book_id": 199054,
    "book": {
      "id": 199054,
      "type": "Book",
      "slug": "blog",
      "name": "博客",
      "user_id": 155457,
      "description": "前端技术博客存档",
      "creator_id": 155457,
      "public": 1,
      "items_count": 15,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-04-23T09:00:45.336Z",
      "updated_at": "2019-04-23T09:00:45.000Z",
      "created_at": "2019-01-06T05:57:32.000Z",
      "namespace": "u46795/blog",
      "user": {
        "id": 155457,
        "type": "User",
        "login": "u46795",
        "name": "Nero",
        "description": "https://github.com/Ghostdar",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 5,
        "public_books_count": 5,
        "followers_count": 12,
        "following_count": 5,
        "created_at": "2018-08-04T03:45:56.000Z",
        "updated_at": "2019-04-30T15:08:36.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 155457,
    "creator": {
      "id": 155457,
      "type": "User",
      "login": "u46795",
      "name": "Nero",
      "description": "https://github.com/Ghostdar",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 5,
      "public_books_count": 5,
      "followers_count": 12,
      "following_count": 5,
      "created_at": "2018-08-04T03:45:56.000Z",
      "updated_at": "2019-04-30T15:08:36.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "date: 2017-03-17 13:45:36<br />categories: '前端'<br />tags: ['http','前端']\n\n---\n\n众所周知，在网站建设这条康庄大道上，从前端架构到后端、服务器的架构，有许多的解决方案，各种高新技术更是层出不穷。本文将以一个网站的前端为入口，从前端层、后端层到服务器层，分析网站的架构、前后端技术栈以及网站的优化技术，管中窥豹，来认识这条大道~<br /><!-- more -->\n<a name=\"7bef39ec\"></a>\n## 1. 服务器层面：\n\n<a name=\"d3832aad\"></a>\n#### 1. 支撑架构（Nginx、IIS、Apache）:\n\n```\nServer: nginx/1.4.6 (Ubuntu)\n```\n\n> 由Response Header 中Server字段可知，服务器使用的是Ubuntu系统，服务器是Nginx/1.4.6 .\n\n\n<a name=\"446c660a\"></a>\n#### 2. 数据库\n\n<a name=\"d3c70a0c\"></a>\n#### 3. 服务器优化：\n\n<a name=\"17420713\"></a>\n###### 1. HSTS头部：\n\n> 当用户使用http访问时，会返回一个302重定向，重定向到https的地址，后续访问都由https传输，而由于302重定向容易被篡改，这样的通信模式存在一定的风险。\n\n\n```\nStrict-Transport-Security:max-age=15768000\n```\n\n> - 由Response Header 中Strict-Transport-Security 字段可知，服务器端开启了Strict-Transport-Security功能，其作用是作用是强制客户端（如浏览器）使用HTTPS与服务器创建连接。\n\n\n> - HSTS可以很大程度上解决SSL剥离攻击，因为只要浏览器曾经与服务器创建过一次安全连接，之后浏览器会强制使用HTTPS，即使链接被换成了HTTP，另外，如果中间人使用自己的自签名证书来进行攻击，浏览器会给出警告，但是许多用户会忽略警告。HSTS解决了这一问题，一旦服务器发送了HSTS字段，用户将不再允许忽略警告.\n\n\n<a name=\"03f02235\"></a>\n## 2.后端技术架构：\n\n<a name=\"68ce2833\"></a>\n#### 1. 同构/异构:\n\n<a name=\"0c79b974\"></a>\n#### 2. 语言、框架:\n\n```\nX-Powered-By: Express(Nodejs)\n```\n\n> 由Response Header 中X-Powered-By 字段可得知，服务器语言使用的是Node.js ,使用的框架是Express .\n\n\n<a name=\"7a5bcbc1\"></a>\n#### 3. 鉴权、前后端API：\n\n<a name=\"82fcfd11\"></a>\n#### 4. 后端优化：\n\n<a name=\"266d0f73\"></a>\n###### 1. 服务端压缩：\n\n```\nContent-Encoding:gzip\n```\n\n> - 由Response Header 中Content-Encoding字段可得知服务器使用的是gzip文本压缩格式.\n\n\n> - 浏览器发送请求时，通过 Accept-Encoding 带上自己支持的内容编码格式列表；服务端从中挑选一种用来对正文进行编码，并通过 Content-Encoding 响应头指明选定的格式；浏览器拿到响应正文后，依据 Content-Encoding 进行解压。\n\n\n<a name=\"6b786eed\"></a>\n###### 2. HTTP缓存控制：\n\n```\nCache-control:public, max-age=7200\nETag:W/\"c95b-1Lg4JB+MjVViSanrBU0LRg\"\n```\n\n> 由Response Header 中Cache-control字段可知，访问当前页面后的2h内再次访问，将不会去访问服务器，而去访问缓存。而由ETag字段可知,当cache过期时，浏览器再次请求时要发If-None-Match的请求。CGI据此可以知道这个请求的客户端是否有cache,此时如果 CGI联系server失败，那么可以直接返回304，驱使客户端使用上一次cache的正确结果，且更新保鲜期max-age为7200秒,这样我们实现了一个基于HTTP cache的容错.\n\n\n> - Expires策略：Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。Expires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大（比如时钟不同步，或者跨时区），那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。\n\n\n> - Cache-control策略：Cache-Control与Expires的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires\n\n\n> - Last-Modified：标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。<br />\nIf-Modified-Since：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 If-Modified-Since，表示请求时间。web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用所保存的cache。\n\n\n> - Etag：web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。<br />\nIf-None-Match：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定返回200或304。\n\n\n> - Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间,如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存,有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形.Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。Last-Modified与ETag一起使用时，服务器会优先验证ETag。\n\n\n<a name=\"15dee2f3\"></a>\n###### 3. CSRF防护：\n\n```\n<meta content=\"_csrf\" name=\"csrf-param\">\n<meta content=\"6eEHcEur-Q-CoC0eMc3GIRofusFMhD6fYr4Y\" name=\"csrf-token\">\n```\n\n> 分析首页html代码可知：服务端做了CSRF防护，由服务端生成crsf-token，每次请求都将和服务端的进行对比。\n\n\n> csrf 防护策略：\n\n\n- 通过 referer、token 或者 验证码 来检测用户提交。\n- 尽量不要在页面的链接中暴露用户隐私信息。\n- 对于用户修改删除等操作最好都使用post 操作 。\n- 避免全站通用的cookie，严格设置cookie的域\n\n<a name=\"ed1b2abe\"></a>\n## 3.前端技术栈：\n\n<a name=\"5fdf1e45\"></a>\n#### 1. 框架：\n\n<a name=\"050d5dae\"></a>\n#### 2. 工具：\n\n<a name=\"8eaf9bb8\"></a>\n#### 3. 库：\n\n```\n<link rel=\"stylesheet\" href=\"//o4j806krb.qnssl.com/public/stylesheets/index.min.9d1ebdbb.min.css\" media=\"all\" />\n```\n\n> 由首页中引入标签可知，首页引进了Bootstrap/v2.3.1 框架，并使用了cdn资源优化。\n\n\n<a name=\"729f5659\"></a>\n#### 4. 标准化（代码、常见优化点、模块化）：\n\n<a name=\"ddc6c08c\"></a>\n###### 1. CDN优化：\n\n- 文件资源：\n\n```\n<link rel=\"stylesheet\" href=\"//o4j806krb.qnssl.com/public/stylesheets/index.min.9d1ebdbb.min.css\" media=\"all\" />\n```\n\n- 图片资源：\n\n```\n<img src=\"//dn-cnode.qbox.me/Fn4D6BhOTz1IswvmzeZ1q7QW1ls_\">\n```\n\n> 由上述首页代码可知，网站资源引入采用了cdn优化，有dn-cnode.qbox.me和o4j806krb.qnssl.com等cdn服务站。\n\n\n> CDN(Content Delivery Network)内容分发网络：通过在现有的Internet中增加一层新的网络架构，部署边缘服务器，将网站的内容发布到最接近用户的Cache服务器，使用户可以就近取得所需的内容，实现用户就近访问，有效提升网站的访问效果、安全性和稳定性。\n\n\n<a name=\"f590d0c2\"></a>\n###### 2. RSS优化:\n\n```\n<link title=\"RSS\" type=\"application/rss+xml\" rel=\"alternate\" href=\"/rss\"/>\n```\n\n> 由上述首页标签可知，本站首页内部加入了RSS源。有以下好处：\n\n\n1. 搜索引擎会认为有rss源的网站有更好的用户体验。\n2. 订阅该网站的用户会第一时间看到网站更新的内容。\n3. 配合百度的ping功能使用，RSS数据提交给搜索引擎后，能加快搜索引擎收录与信息的推广。\n\n- RSS:在线共享内容的一种简易方式（也叫聚合内容，全称Really Simple Syndication）。使用RSS订阅能更快地速获取信息和获取网站内容的最新更新。更直白的说，你可以不用再一一打开各个网站页面，而是通过阅读器一次一起阅读所有你订阅了的网站的最新内容。\n\n<a name=\"96d1b5d2\"></a>\n###### 3. 分块编码：\n\n```\nTransfer-Encoding:chunked\n```\n\n> 由Response Header 中Transfer-Encoding字段可得知,网站采用了分块传输编码.\n\n\n- Transfer-Encoding的作用：对于非持久连接，浏览器可以通过连接是否关闭来界定请求或响应实体的边界；而对于持久连接，这种方法显然不奏效.要解决上面这个问题，最容易想到的办法就是计算实体长度，并通过头部告诉对方。这就要用到 Content-Length 了,通常如果 Content-Length 比实际长度短，会造成内容被截断；如果比实体内容长，会造成 pending.服务端为了计算响应实体长度而缓存所有内容，跟更短的 TTFB 理念背道而驰。但在 HTTP 报文中，实体一定要在头部之后，顺序不能颠倒，为此我们需要一个新的机制：不依赖头部的长度信息，也能知道实体的边界.Transfer-Encoding 正是用来解决上面这个问题的. 历史上 Transfer-Encoding 可以有多种取值，为此还引入了一个名为 TE 的头部用来协商采用何种传输编码。但是最新的 HTTP 规范里，只定义了一种传输编码：分块编码（chunked）. 在头部加入 Transfer-Encoding: chunked 之后，就代表这个报文采用了分块编码。这时，报文中的实体需要改为用一系列分块来传输。每个分块包含十六进制的长度值和数据，长度值独占一行，长度不包括它结尾的 CRLF（\\r\\n），也不包括分块数据结尾的 CRLF。最后一个分块长度值必须为 0，对应的分块数据没有内容，表示实体结束.通过这种简单的分块策略，很好的解决了前面提出的问题.\n\n- Transfer-Encoding: identity ?\n\n\n<a name=\"3c592a5d\"></a>\n#### 5. 前端工程化：\n\n```\nhttps://o4j806krb.qnssl.com/public/index.min.aeb155e1.min.js\n```\n\n> 由此文件可知，js文件经过了压缩，混淆操作。\n\n",
    "body_draft": "",
    "body_html": "<p>date: 2017-03-17 13:45:36</p><p>categories: '前端'</p><p>tags: ['http','前端']</p><hr /><p>众所周知，在网站建设这条康庄大道上，从前端架构到后端、服务器的架构，有许多的解决方案，各种高新技术更是层出不穷。本文将以一个网站的前端为入口，从前端层、后端层到服务器层，分析网站的架构、前后端技术栈以及网站的优化技术，管中窥豹，来认识这条大道~</p><p>&lt;!-- more --&gt;</p><h2 id=\"7bef39ec\">1. 服务器层面：</h2><p><br /></p><h4 id=\"d3832aad\">1. 支撑架构（Nginx、IIS、Apache）:</h4><p><br /></p><pre><code>Server: nginx/1.4.6 (Ubuntu)</code></pre><p><br /></p><blockquote><p>由Response Header 中Server字段可知，服务器使用的是Ubuntu系统，服务器是Nginx/1.4.6 .</p></blockquote><p><br /></p><h4 id=\"446c660a\">2. 数据库</h4><p><br /></p><h4 id=\"d3c70a0c\">3. 服务器优化：</h4><p><br /></p><h6 id=\"17420713\">1. HSTS头部：</h6><p><br /></p><blockquote><p>当用户使用http访问时，会返回一个302重定向，重定向到https的地址，后续访问都由https传输，而由于302重定向容易被篡改，这样的通信模式存在一定的风险。</p></blockquote><p><br /></p><pre><code>Strict-Transport-Security:max-age=15768000</code></pre><p><br /></p><blockquote><ul><li>由Response Header 中Strict-Transport-Security 字段可知，服务器端开启了Strict-Transport-Security功能，其作用是作用是强制客户端（如浏览器）使用HTTPS与服务器创建连接。</li></ul></blockquote><p><br /></p><blockquote><ul><li>HSTS可以很大程度上解决SSL剥离攻击，因为只要浏览器曾经与服务器创建过一次安全连接，之后浏览器会强制使用HTTPS，即使链接被换成了HTTP，另外，如果中间人使用自己的自签名证书来进行攻击，浏览器会给出警告，但是许多用户会忽略警告。HSTS解决了这一问题，一旦服务器发送了HSTS字段，用户将不再允许忽略警告.</li></ul></blockquote><p><br /></p><h2 id=\"03f02235\">2.后端技术架构：</h2><p><br /></p><h4 id=\"68ce2833\">1. 同构/异构:</h4><p><br /></p><h4 id=\"0c79b974\">2. 语言、框架:</h4><p><br /></p><pre><code>X-Powered-By: Express(Nodejs)</code></pre><p><br /></p><blockquote><p>由Response Header 中X-Powered-By 字段可得知，服务器语言使用的是Node.js ,使用的框架是Express .</p></blockquote><p><br /></p><h4 id=\"7a5bcbc1\">3. 鉴权、前后端API：</h4><p><br /></p><h4 id=\"82fcfd11\">4. 后端优化：</h4><p><br /></p><h6 id=\"266d0f73\">1. 服务端压缩：</h6><p><br /></p><pre><code>Content-Encoding:gzip</code></pre><p><br /></p><blockquote><ul><li>由Response Header 中Content-Encoding字段可得知服务器使用的是gzip文本压缩格式.</li></ul></blockquote><p><br /></p><blockquote><ul><li>浏览器发送请求时，通过 Accept-Encoding 带上自己支持的内容编码格式列表；服务端从中挑选一种用来对正文进行编码，并通过 Content-Encoding 响应头指明选定的格式；浏览器拿到响应正文后，依据 Content-Encoding 进行解压。</li></ul></blockquote><p><br /></p><h6 id=\"6b786eed\">2. HTTP缓存控制：</h6><p><br /></p><pre><code>Cache-control:public, max-age=7200\nETag:W/&quot;c95b-1Lg4JB+MjVViSanrBU0LRg&quot;</code></pre><p><br /></p><blockquote><p>由Response Header 中Cache-control字段可知，访问当前页面后的2h内再次访问，将不会去访问服务器，而去访问缓存。而由ETag字段可知,当cache过期时，浏览器再次请求时要发If-None-Match的请求。CGI据此可以知道这个请求的客户端是否有cache,此时如果 CGI联系server失败，那么可以直接返回304，驱使客户端使用上一次cache的正确结果，且更新保鲜期max-age为7200秒,这样我们实现了一个基于HTTP cache的容错.</p></blockquote><p><br /></p><blockquote><ul><li>Expires策略：Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。Expires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大（比如时钟不同步，或者跨时区），那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。</li></ul></blockquote><p><br /></p><blockquote><ul><li>Cache-control策略：Cache-Control与Expires的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires</li></ul></blockquote><p><br /></p><blockquote><ul><li>Last-Modified：标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。<br />\nIf-Modified-Since：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 If-Modified-Since，表示请求时间。web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用所保存的cache。</li></ul></blockquote><p><br /></p><blockquote><ul><li>Etag：web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。<br />\nIf-None-Match：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定返回200或304。</li></ul></blockquote><p><br /></p><blockquote><ul><li>Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间,如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存,有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形.Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。Last-Modified与ETag一起使用时，服务器会优先验证ETag。</li></ul></blockquote><p><br /></p><h6 id=\"15dee2f3\">3. CSRF防护：</h6><p><br /></p><pre><code>&lt;meta content=&quot;_csrf&quot; name=&quot;csrf-param&quot;&gt;\n&lt;meta content=&quot;6eEHcEur-Q-CoC0eMc3GIRofusFMhD6fYr4Y&quot; name=&quot;csrf-token&quot;&gt;</code></pre><p><br /></p><blockquote><p>分析首页html代码可知：服务端做了CSRF防护，由服务端生成crsf-token，每次请求都将和服务端的进行对比。</p></blockquote><p><br /></p><blockquote><p>csrf 防护策略：</p></blockquote><p><br /></p><ul><li>通过 referer、token 或者 验证码 来检测用户提交。</li></ul><ul><li>尽量不要在页面的链接中暴露用户隐私信息。</li></ul><ul><li>对于用户修改删除等操作最好都使用post 操作 。</li></ul><ul><li>避免全站通用的cookie，严格设置cookie的域</li></ul><p><br /></p><h2 id=\"ed1b2abe\">3.前端技术栈：</h2><p><br /></p><h4 id=\"5fdf1e45\">1. 框架：</h4><p><br /></p><h4 id=\"050d5dae\">2. 工具：</h4><p><br /></p><h4 id=\"8eaf9bb8\">3. 库：</h4><p><br /></p><pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;//o4j806krb.qnssl.com/public/stylesheets/index.min.9d1ebdbb.min.css&quot; media=&quot;all&quot; /&gt;</code></pre><p><br /></p><blockquote><p>由首页中引入标签可知，首页引进了Bootstrap/v2.3.1 框架，并使用了cdn资源优化。</p></blockquote><p><br /></p><h4 id=\"729f5659\">4. 标准化（代码、常见优化点、模块化）：</h4><p><br /></p><h6 id=\"ddc6c08c\">1. CDN优化：</h6><p><br /></p><ul><li>文件资源：</li></ul><p><br /></p><pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;//o4j806krb.qnssl.com/public/stylesheets/index.min.9d1ebdbb.min.css&quot; media=&quot;all&quot; /&gt;</code></pre><p><br /></p><ul><li>图片资源：</li></ul><p><br /></p><pre><code>&lt;img src=&quot;//dn-cnode.qbox.me/Fn4D6BhOTz1IswvmzeZ1q7QW1ls_&quot;&gt;</code></pre><p><br /></p><blockquote><p>由上述首页代码可知，网站资源引入采用了cdn优化，有dn-cnode.qbox.me和o4j806krb.qnssl.com等cdn服务站。</p></blockquote><p><br /></p><blockquote><p>CDN(Content Delivery Network)内容分发网络：通过在现有的Internet中增加一层新的网络架构，部署边缘服务器，将网站的内容发布到最接近用户的Cache服务器，使用户可以就近取得所需的内容，实现用户就近访问，有效提升网站的访问效果、安全性和稳定性。</p></blockquote><p><br /></p><h6 id=\"f590d0c2\">2. RSS优化:</h6><p><br /></p><pre><code>&lt;link title=&quot;RSS&quot; type=&quot;application/rss+xml&quot; rel=&quot;alternate&quot; href=&quot;/rss&quot;/&gt;</code></pre><p><br /></p><blockquote><p>由上述首页标签可知，本站首页内部加入了RSS源。有以下好处：</p></blockquote><p><br /></p><ol start=\"1\"><li>搜索引擎会认为有rss源的网站有更好的用户体验。</li></ol><ol start=\"2\"><li>订阅该网站的用户会第一时间看到网站更新的内容。</li></ol><ol start=\"3\"><li>配合百度的ping功能使用，RSS数据提交给搜索引擎后，能加快搜索引擎收录与信息的推广。</li></ol><p><br /></p><ul><li>RSS:在线共享内容的一种简易方式（也叫聚合内容，全称Really Simple Syndication）。使用RSS订阅能更快地速获取信息和获取网站内容的最新更新。更直白的说，你可以不用再一一打开各个网站页面，而是通过阅读器一次一起阅读所有你订阅了的网站的最新内容。</li></ul><p><br /></p><h6 id=\"96d1b5d2\">3. 分块编码：</h6><p><br /></p><pre><code>Transfer-Encoding:chunked</code></pre><p><br /></p><blockquote><p>由Response Header 中Transfer-Encoding字段可得知,网站采用了分块传输编码.</p></blockquote><p><br /></p><ul><li><p>Transfer-Encoding的作用：对于非持久连接，浏览器可以通过连接是否关闭来界定请求或响应实体的边界；而对于持久连接，这种方法显然不奏效.要解决上面这个问题，最容易想到的办法就是计算实体长度，并通过头部告诉对方。这就要用到 Content-Length 了,通常如果 Content-Length 比实际长度短，会造成内容被截断；如果比实体内容长，会造成 pending.服务端为了计算响应实体长度而缓存所有内容，跟更短的 TTFB 理念背道而驰。但在 HTTP 报文中，实体一定要在头部之后，顺序不能颠倒，为此我们需要一个新的机制：不依赖头部的长度信息，也能知道实体的边界.Transfer-Encoding 正是用来解决上面这个问题的. 历史上 Transfer-Encoding 可以有多种取值，为此还引入了一个名为 TE 的头部用来协商采用何种传输编码。但是最新的 HTTP 规范里，只定义了一种传输编码：分块编码（chunked）. 在头部加入 Transfer-Encoding: chunked 之后，就代表这个报文采用了分块编码。这时，报文中的实体需要改为用一系列分块来传输。每个分块包含十六进制的长度值和数据，长度值独占一行，长度不包括它结尾的 CRLF（\\r\\n），也不包括分块数据结尾的 CRLF。最后一个分块长度值必须为 0，对应的分块数据没有内容，表示实体结束.通过这种简单的分块策略，很好的解决了前面提出的问题.</p></li></ul><ul><li><p>Transfer-Encoding: identity ?</p></li></ul><p><br /></p><h4 id=\"3c592a5d\">5. 前端工程化：</h4><p><br /></p><pre><code>https://o4j806krb.qnssl.com/public/index.min.aeb155e1.min.js</code></pre><p><br /></p><blockquote><p>由此文件可知，js文件经过了压缩，混淆操作。</p></blockquote>",
    "body_lake": "<!doctype lake><p>date: 2017-03-17 13:45:36</p><p>cate<cursor />gories: '前端'</p><p>tags: ['http','前端']</p><card type=\"block\" name=\"hr\"></card><p>众所周知，在网站建设这条康庄大道上，从前端架构到后端、服务器的架构，有许多的解决方案，各种高新技术更是层出不穷。本文将以一个网站的前端为入口，从前端层、后端层到服务器层，分析网站的架构、前后端技术栈以及网站的优化技术，管中窥豹，来认识这条大道~</p><p>&lt;!-- more --&gt;</p><h2 id=\"7bef39ec\">1. 服务器层面：</h2><p><br /></p><h4 id=\"d3832aad\">1. 支撑架构（Nginx、IIS、Apache）:</h4><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22code%22%3A%22Server%3A%20nginx%2F1.4.6%20(Ubuntu)%22%7D\"></card><p><br /></p><blockquote><p>由Response Header 中Server字段可知，服务器使用的是Ubuntu系统，服务器是Nginx/1.4.6 .</p></blockquote><p><br /></p><h4 id=\"446c660a\">2. 数据库</h4><p><br /></p><h4 id=\"d3c70a0c\">3. 服务器优化：</h4><p><br /></p><h6 id=\"17420713\">1. HSTS头部：</h6><p><br /></p><blockquote><p>当用户使用http访问时，会返回一个302重定向，重定向到https的地址，后续访问都由https传输，而由于302重定向容易被篡改，这样的通信模式存在一定的风险。</p></blockquote><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22code%22%3A%22Strict-Transport-Security%3Amax-age%3D15768000%22%7D\"></card><p><br /></p><blockquote><ul><li>由Response Header 中Strict-Transport-Security 字段可知，服务器端开启了Strict-Transport-Security功能，其作用是作用是强制客户端（如浏览器）使用HTTPS与服务器创建连接。</li></ul></blockquote><p><br /></p><blockquote><ul><li>HSTS可以很大程度上解决SSL剥离攻击，因为只要浏览器曾经与服务器创建过一次安全连接，之后浏览器会强制使用HTTPS，即使链接被换成了HTTP，另外，如果中间人使用自己的自签名证书来进行攻击，浏览器会给出警告，但是许多用户会忽略警告。HSTS解决了这一问题，一旦服务器发送了HSTS字段，用户将不再允许忽略警告.</li></ul></blockquote><p><br /></p><h2 id=\"03f02235\">2.后端技术架构：</h2><p><br /></p><h4 id=\"68ce2833\">1. 同构/异构:</h4><p><br /></p><h4 id=\"0c79b974\">2. 语言、框架:</h4><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22code%22%3A%22X-Powered-By%3A%20Express(Nodejs)%22%7D\"></card><p><br /></p><blockquote><p>由Response Header 中X-Powered-By 字段可得知，服务器语言使用的是Node.js ,使用的框架是Express .</p></blockquote><p><br /></p><h4 id=\"7a5bcbc1\">3. 鉴权、前后端API：</h4><p><br /></p><h4 id=\"82fcfd11\">4. 后端优化：</h4><p><br /></p><h6 id=\"266d0f73\">1. 服务端压缩：</h6><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22code%22%3A%22Content-Encoding%3Agzip%22%7D\"></card><p><br /></p><blockquote><ul><li>由Response Header 中Content-Encoding字段可得知服务器使用的是gzip文本压缩格式.</li></ul></blockquote><p><br /></p><blockquote><ul><li>浏览器发送请求时，通过 Accept-Encoding 带上自己支持的内容编码格式列表；服务端从中挑选一种用来对正文进行编码，并通过 Content-Encoding 响应头指明选定的格式；浏览器拿到响应正文后，依据 Content-Encoding 进行解压。</li></ul></blockquote><p><br /></p><h6 id=\"6b786eed\">2. HTTP缓存控制：</h6><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22code%22%3A%22Cache-control%3Apublic%2C%20max-age%3D7200%5CnETag%3AW%2F%5C%22c95b-1Lg4JB%2BMjVViSanrBU0LRg%5C%22%22%7D\"></card><p><br /></p><blockquote><p>由Response Header 中Cache-control字段可知，访问当前页面后的2h内再次访问，将不会去访问服务器，而去访问缓存。而由ETag字段可知,当cache过期时，浏览器再次请求时要发If-None-Match的请求。CGI据此可以知道这个请求的客户端是否有cache,此时如果 CGI联系server失败，那么可以直接返回304，驱使客户端使用上一次cache的正确结果，且更新保鲜期max-age为7200秒,这样我们实现了一个基于HTTP cache的容错.</p></blockquote><p><br /></p><blockquote><ul><li>Expires策略：Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。Expires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大（比如时钟不同步，或者跨时区），那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。</li></ul></blockquote><p><br /></p><blockquote><ul><li>Cache-control策略：Cache-Control与Expires的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires</li></ul></blockquote><p><br /></p><blockquote><ul><li>Last-Modified：标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。<br />\nIf-Modified-Since：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 If-Modified-Since，表示请求时间。web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用所保存的cache。</li></ul></blockquote><p><br /></p><blockquote><ul><li>Etag：web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。<br />\nIf-None-Match：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定返回200或304。</li></ul></blockquote><p><br /></p><blockquote><ul><li>Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间,如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存,有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形.Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。Last-Modified与ETag一起使用时，服务器会优先验证ETag。</li></ul></blockquote><p><br /></p><h6 id=\"15dee2f3\">3. CSRF防护：</h6><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22code%22%3A%22%3Cmeta%20content%3D%5C%22_csrf%5C%22%20name%3D%5C%22csrf-param%5C%22%3E%5Cn%3Cmeta%20content%3D%5C%226eEHcEur-Q-CoC0eMc3GIRofusFMhD6fYr4Y%5C%22%20name%3D%5C%22csrf-token%5C%22%3E%22%7D\"></card><p><br /></p><blockquote><p>分析首页html代码可知：服务端做了CSRF防护，由服务端生成crsf-token，每次请求都将和服务端的进行对比。</p></blockquote><p><br /></p><blockquote><p>csrf 防护策略：</p></blockquote><p><br /></p><ul><li>通过 referer、token 或者 验证码 来检测用户提交。</li></ul><ul><li>尽量不要在页面的链接中暴露用户隐私信息。</li></ul><ul><li>对于用户修改删除等操作最好都使用post 操作 。</li></ul><ul><li>避免全站通用的cookie，严格设置cookie的域</li></ul><p><br /></p><h2 id=\"ed1b2abe\">3.前端技术栈：</h2><p><br /></p><h4 id=\"5fdf1e45\">1. 框架：</h4><p><br /></p><h4 id=\"050d5dae\">2. 工具：</h4><p><br /></p><h4 id=\"8eaf9bb8\">3. 库：</h4><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22code%22%3A%22%3Clink%20rel%3D%5C%22stylesheet%5C%22%20href%3D%5C%22%2F%2Fo4j806krb.qnssl.com%2Fpublic%2Fstylesheets%2Findex.min.9d1ebdbb.min.css%5C%22%20media%3D%5C%22all%5C%22%20%2F%3E%22%7D\"></card><p><br /></p><blockquote><p>由首页中引入标签可知，首页引进了Bootstrap/v2.3.1 框架，并使用了cdn资源优化。</p></blockquote><p><br /></p><h4 id=\"729f5659\">4. 标准化（代码、常见优化点、模块化）：</h4><p><br /></p><h6 id=\"ddc6c08c\">1. CDN优化：</h6><p><br /></p><ul><li>文件资源：</li></ul><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22code%22%3A%22%3Clink%20rel%3D%5C%22stylesheet%5C%22%20href%3D%5C%22%2F%2Fo4j806krb.qnssl.com%2Fpublic%2Fstylesheets%2Findex.min.9d1ebdbb.min.css%5C%22%20media%3D%5C%22all%5C%22%20%2F%3E%22%7D\"></card><p><br /></p><ul><li>图片资源：</li></ul><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22code%22%3A%22%3Cimg%20src%3D%5C%22%2F%2Fdn-cnode.qbox.me%2FFn4D6BhOTz1IswvmzeZ1q7QW1ls_%5C%22%3E%22%7D\"></card><p><br /></p><blockquote><p>由上述首页代码可知，网站资源引入采用了cdn优化，有dn-cnode.qbox.me和o4j806krb.qnssl.com等cdn服务站。</p></blockquote><p><br /></p><blockquote><p>CDN(Content Delivery Network)内容分发网络：通过在现有的Internet中增加一层新的网络架构，部署边缘服务器，将网站的内容发布到最接近用户的Cache服务器，使用户可以就近取得所需的内容，实现用户就近访问，有效提升网站的访问效果、安全性和稳定性。</p></blockquote><p><br /></p><h6 id=\"f590d0c2\">2. RSS优化:</h6><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22code%22%3A%22%3Clink%20title%3D%5C%22RSS%5C%22%20type%3D%5C%22application%2Frss%2Bxml%5C%22%20rel%3D%5C%22alternate%5C%22%20href%3D%5C%22%2Frss%5C%22%2F%3E%22%7D\"></card><p><br /></p><blockquote><p>由上述首页标签可知，本站首页内部加入了RSS源。有以下好处：</p></blockquote><p><br /></p><ol start=\"1\"><li>搜索引擎会认为有rss源的网站有更好的用户体验。</li></ol><ol start=\"2\"><li>订阅该网站的用户会第一时间看到网站更新的内容。</li></ol><ol start=\"3\"><li>配合百度的ping功能使用，RSS数据提交给搜索引擎后，能加快搜索引擎收录与信息的推广。</li></ol><p><br /></p><ul><li>RSS:在线共享内容的一种简易方式（也叫聚合内容，全称Really Simple Syndication）。使用RSS订阅能更快地速获取信息和获取网站内容的最新更新。更直白的说，你可以不用再一一打开各个网站页面，而是通过阅读器一次一起阅读所有你订阅了的网站的最新内容。</li></ul><p><br /></p><h6 id=\"96d1b5d2\">3. 分块编码：</h6><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22code%22%3A%22Transfer-Encoding%3Achunked%22%7D\"></card><p><br /></p><blockquote><p>由Response Header 中Transfer-Encoding字段可得知,网站采用了分块传输编码.</p></blockquote><p><br /></p><ul><li><p>Transfer-Encoding的作用：对于非持久连接，浏览器可以通过连接是否关闭来界定请求或响应实体的边界；而对于持久连接，这种方法显然不奏效.要解决上面这个问题，最容易想到的办法就是计算实体长度，并通过头部告诉对方。这就要用到 Content-Length 了,通常如果 Content-Length 比实际长度短，会造成内容被截断；如果比实体内容长，会造成 pending.服务端为了计算响应实体长度而缓存所有内容，跟更短的 TTFB 理念背道而驰。但在 HTTP 报文中，实体一定要在头部之后，顺序不能颠倒，为此我们需要一个新的机制：不依赖头部的长度信息，也能知道实体的边界.Transfer-Encoding 正是用来解决上面这个问题的. 历史上 Transfer-Encoding 可以有多种取值，为此还引入了一个名为 TE 的头部用来协商采用何种传输编码。但是最新的 HTTP 规范里，只定义了一种传输编码：分块编码（chunked）. 在头部加入 Transfer-Encoding: chunked 之后，就代表这个报文采用了分块编码。这时，报文中的实体需要改为用一系列分块来传输。每个分块包含十六进制的长度值和数据，长度值独占一行，长度不包括它结尾的 CRLF（\\r\\n），也不包括分块数据结尾的 CRLF。最后一个分块长度值必须为 0，对应的分块数据没有内容，表示实体结束.通过这种简单的分块策略，很好的解决了前面提出的问题.</p></li></ul><ul><li><p>Transfer-Encoding: identity ?</p></li></ul><p><br /></p><h4 id=\"3c592a5d\">5. 前端工程化：</h4><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22code%22%3A%22https%3A%2F%2Fo4j806krb.qnssl.com%2Fpublic%2Findex.min.aeb155e1.min.js%22%7D\"></card><p><br /></p><blockquote><p>由此文件可知，js文件经过了压缩，混淆操作。</p></blockquote>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-01-14T03:05:20.000Z",
    "deleted_at": null,
    "created_at": "2019-01-12T03:35:29.000Z",
    "updated_at": "2019-01-14T03:05:21.000Z",
    "published_at": "2019-01-14T03:05:20.000Z",
    "first_published_at": "2019-01-12T03:38:06.000Z",
    "word_count": 2726,
    "cover": null,
    "description": "date: 2017-03-17 13:45:36categories: '前端'tags: ['http','前端']众所周知，在网站建设这条康庄大道上，从前端架构到后端、服务器的架构，有许多的解决方案，各种高新技术更是层出不穷。本文将以一个网站的前端为入口，从前端层、后端层到服务器层，分析...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1125056,
    "slug": "wi2za4",
    "title": "2018总结（长文）",
    "book_id": 199054,
    "book": {
      "id": 199054,
      "type": "Book",
      "slug": "blog",
      "name": "博客",
      "user_id": 155457,
      "description": "前端技术博客存档",
      "creator_id": 155457,
      "public": 1,
      "items_count": 15,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-04-23T09:00:45.336Z",
      "updated_at": "2019-04-23T09:00:45.000Z",
      "created_at": "2019-01-06T05:57:32.000Z",
      "namespace": "u46795/blog",
      "user": {
        "id": 155457,
        "type": "User",
        "login": "u46795",
        "name": "Nero",
        "description": "https://github.com/Ghostdar",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 5,
        "public_books_count": 5,
        "followers_count": 12,
        "following_count": 5,
        "created_at": "2018-08-04T03:45:56.000Z",
        "updated_at": "2019-04-30T15:08:36.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 155457,
    "creator": {
      "id": 155457,
      "type": "User",
      "login": "u46795",
      "name": "Nero",
      "description": "https://github.com/Ghostdar",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 5,
      "public_books_count": 5,
      "followers_count": 12,
      "following_count": 5,
      "created_at": "2018-08-04T03:45:56.000Z",
      "updated_at": "2019-04-30T15:08:36.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "",
    "body_draft": "",
    "body_html": "",
    "body_lake": "",
    "public": 1,
    "status": 0,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-01-16T12:47:23.000Z",
    "deleted_at": null,
    "created_at": "2019-01-08T09:43:28.000Z",
    "updated_at": "2019-01-16T12:47:23.000Z",
    "published_at": null,
    "first_published_at": null,
    "word_count": 0,
    "cover": null,
    "description": "引言：自17年6月转前端以来（哈哈，本人之前是个后端），在腾讯爸爸的怀抱里飞快成长，一眨眼就一年多了，应sgemenetfault社区的号召。抽时间整理了一下一年以来的成长与收获，不止于前端~关于前端先上一张我的知识体系图谱：牢固地基基础是非常重要的，特别是在大厂，所谓万变不离其宗，所有的框架...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1120595,
    "slug": "dlloc7",
    "title": "Hexo 博客终极玩法：云端写作，自动部署",
    "book_id": 199054,
    "book": {
      "id": 199054,
      "type": "Book",
      "slug": "blog",
      "name": "博客",
      "user_id": 155457,
      "description": "前端技术博客存档",
      "creator_id": 155457,
      "public": 1,
      "items_count": 15,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-04-23T09:00:45.336Z",
      "updated_at": "2019-04-23T09:00:45.000Z",
      "created_at": "2019-01-06T05:57:32.000Z",
      "namespace": "u46795/blog",
      "user": {
        "id": 155457,
        "type": "User",
        "login": "u46795",
        "name": "Nero",
        "description": "https://github.com/Ghostdar",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 5,
        "public_books_count": 5,
        "followers_count": 12,
        "following_count": 5,
        "created_at": "2018-08-04T03:45:56.000Z",
        "updated_at": "2019-04-30T15:08:36.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 155457,
    "creator": {
      "id": 155457,
      "type": "User",
      "login": "u46795",
      "name": "Nero",
      "description": "https://github.com/Ghostdar",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 5,
      "public_books_count": 5,
      "followers_count": 12,
      "following_count": 5,
      "created_at": "2018-08-04T03:45:56.000Z",
      "updated_at": "2019-04-30T15:08:36.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "tags: [hexo, node]<br />categories: 前端\n\n---\n\nHexo + Github + 语雀 + yuque-hexo +travis-ci+severless 打造全自动持续集成个人博客，云端写作，自动部署，完美体验~<br /><!-- more -->\n<a name=\"b740fe7a\"></a>\n### 一、Hexo+Github 的痛点\n<a name=\"10a80c20\"></a>\n#### 1.为啥要用hexo+github？\n作为一个程序猿，博客肯定是必须要有的拉，github也是必须要混的拉~所以:\n\n- hexo + github = 高大上\n\n![image.jpeg](https://cdn.nlark.com/yuque/0/2019/jpeg/155457/1546857679810-d82e3d46-e960-419c-a715-0a82c48a2fd6.jpeg#align=left&display=inline&height=225&name=image.jpeg&originHeight=225&originWidth=225&size=6267&width=225)\n\n\n<a name=\"e29fe75d\"></a>\n#### 2.蛋疼的写作体验\n使用hexo，会面临如下问题：\n\n- 博客源码怎么管理？\n- 图片存在哪？\n- 如何编写markdown文件？\n\n相信很多人都在使用本地编辑器来写博客，那体验，真心蛋疼，比如说vscode，可视化插件一般般，图片还不能复制黏贴，想插入个图片还要先保存成文件放在本地，然后再引用，啥？你说七牛云存储？哪有复制黏贴爽呀~<br />当然，博客源码可以使用travis-ci 来做持续集成，想写博客或者换个电脑，clone一下源仓库，写完push一下，就可以不用管了。but，比起独立站点的博客，如wordpress，还是觉得写作体验有点不爽。<br />![image.jpeg](https://cdn.nlark.com/yuque/0/2019/jpeg/155457/1546858156666-f3f7ae20-c7f8-49b9-849d-b4364f3685f7.jpeg#align=left&display=inline&height=213&name=image.jpeg&originHeight=213&originWidth=237&size=5810&width=237)\n<a name=\"a1cea4a7\"></a>\n#### 3. 脑洞大开：\n偶然间，朋友安利了语雀这个文档写作平台，觉得这就是完美的写作体验，各种UI和编辑器都很舒服~秀个图：<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/155457/1546858295510-9ca72eb5-b3ae-4d7c-8478-d8d1cda959d0.png#align=left&display=inline&height=821&name=image.png&originHeight=903&originWidth=1789&size=119669&width=1626)\n\nmarkdown编辑器也是巨爽：<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/155457/1546858354478-127bd82a-7958-40ce-b760-07e469bd55ba.png#align=left&display=inline&height=840&name=image.png&originHeight=924&originWidth=1890&size=125288&width=1718)\n\n于是乎，就在想能不能在语雀里写作，写完之后自动同步到Github的博客呢？年轻就要有激情，说干就干，花了一天时间，结合了severless、yuque-hexo、travis-ci之后，终于跑通了整个写作、发布、自动部署的流程~<br />![image.jpeg](https://cdn.nlark.com/yuque/0/2019/jpeg/155457/1546858544992-c921de6f-b08a-469a-bd5f-81996309443b.jpeg#align=left&display=inline&height=225&name=image.jpeg&originHeight=225&originWidth=225&size=10511&width=225)\n<a name=\"62b46819\"></a>\n### 二、具体方案\n整体流程：<br />![工作流.png](https://cdn.nlark.com/yuque/0/2019/png/155457/1546854780929-79a8a0f2-1678-4e16-bf23-52bbc364a5eb.png#align=left&display=inline&height=262&name=%E5%B7%A5%E4%BD%9C%E6%B5%81.png&originHeight=446&originWidth=1268&size=21932&width=746)\n\n  - 语雀发布一篇文章\n  - webhook调用serverless函数\n  - serverless 发起请求 trigger 一个 build 任务\n  - travis-ci 同步语雀文章并构建hexo\n  - github 生成静态页面展示\n<a name=\"8072e205\"></a>\n#### 1. hexo+github+triavs-ci\nhexo如何部署，如何集成travis-ci，等等，我就不再讲了，网上类似的文章灰常多~<br />比如：\n\n- [](https://segmentfault.com/a/1190000013266001)[使用Hexo+Github+TravisCI搭建自动发布的静态博客系统](https://segmentfault.com/a/1190000013266001)\n- [](https://segmentfault.com/a/1190000016487753)[GitHub pages + Hexo 搭建自己的个人博客](https://segmentfault.com/a/1190000016487753)\n\n![image.png](https://cdn.nlark.com/yuque/0/2019/png/155457/1546856496741-e2bcacb7-133f-411f-8696-68e29c280dfc.png#align=left&display=inline&height=225&name=image.png&originHeight=225&originWidth=225&size=3779&width=225)\n\n那么如何同步语雀的文章呢？答案就是：\n<a name=\"yuque-hexo\"></a>\n##### yuque-hexo\n这是一个开源库：[https://github.com/x-cold/yuque-hexo](https://github.com/x-cold/yuque-hexo)<br />用法也很简单：<br />1) 修改package.json，增加配置:\n\n```json\n  \"yuqueConfig\": {\n    \"baseUrl\": \"https://www.yuque.com/api/v2\",\n    \"login\": \"u46795\",\n    \"repo\": \"blog\",\n    \"mdNameFormat\": \"title\",\n    \"postPath\": \"source/_posts/yuque\"\n  },\n```\n2）增加命令：\n\n```json\n  \"scripts\": {\n    \"sync\": \"yuque-hexo sync\",\n    \"clean:yuque\": \"yuque-hexo clean\",\n    \"deploy\": \"npm run sync && hexo clean && hexo g -d\",\n  },\n```\n\n附上我的[package.json](https://github.com/Ghostdar/blog-origin/blob/master/package.json)文件。\n<a name=\"2db9be93\"></a>\n#### 2. serverless\n目前阿里云和腾讯云都有serverless服务，免费的额度完全够用了，下面介绍一下如何配置：\n<a name=\"cd59a2fd\"></a>\n##### 1）创建函数\n![image.png](https://cdn.nlark.com/yuque/0/2019/png/155457/1546855514908-08a6c588-774a-404e-8425-89ce6a3f7167.png#align=left&display=inline&height=697&name=image.png&originHeight=767&originWidth=1408&size=90789&width=1280)\n<a name=\"7fffeff3\"></a>\n##### 2）serverless 函数示例:\n\n```php\n<?php\nfunction main_handler($event, $context) {\n    // 解析语雀post的数据\n    $update_title = '';\n    if($event->body){\n        $yuque_data= json_decode($event->body);\n        $update_title .= $yuque_data->data->title;\n    }\n    // default params\n    $repos = 'xxxx';  // 你的仓库id 或 slug\n    $token = 'xxxxxx'; // 你的登录token\n    $message = date(\"Y/m/d\").':yuque update:'.$update_title;\n    $branch = 'master';\n    // post params\n    $queryString = $event->queryString;\n    $q_token = $queryString->token ? $queryString->token : $token;\n    $q_repos = $queryString->repos ? $queryString->repos : $repos;\n    $q_message = $queryString->message ? $queryString->message : $message;\n    $q_branch = $queryString->branch ? $queryString->branch : 'master';\n    echo($q_token);\n    echo('===');\n    echo ($q_repos);\n    echo ('===');\n    echo ($q_message);\n    echo ('===');\n    echo ($q_branch);\n    echo ('===');\n    //request travis ci\n    $res_info = triggerTravisCI($q_repos, $q_token, $q_message, $q_branch);\n\n    $res_code = 0;\n    $res_message = '未知';\n    if($res_info['http_code']){\n        $res_code = $res_info['http_code'];\n        switch($res_info['http_code']){\n            case 200:\n            case 202:\n                $res_message = 'success';\n            break;\n            default:\n                $res_message = 'faild';\n            break;\n        }\n    }\n    $res = array(\n        'status'=>$res_code,\n        'message'=>$res_message\n    );\n    return $res;\n}\n\n/*\n* @description  travis api , trigger a build\n* @param $repos string 仓库ID、slug\n* @param $token string 登录验证token\n* @param $message string 触发信息\n* @param $branch string 分支\n* @return $info array 回包信息\n*/\nfunction triggerTravisCI ($repos, $token, $message='yuque update', $branch='master') {\n    //初始化\n    $curl = curl_init();\n    //设置抓取的url\n    curl_setopt($curl, CURLOPT_URL, 'https://api.travis-ci.org/repo/'.$repos.'/requests');\n    //设置获取的信息以文件流的形式返回，而不是直接输出。\n    curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);\n    //设置post方式提交\n    curl_setopt($curl, CURLOPT_CUSTOMREQUEST, \"POST\");\n    //设置post数据\n    $post_data = json_encode(array(\n        \"request\"=> array(\n            \"message\"=>$message,\n            \"branch\"=>$branch\n        )\n    ));\n    $header = array(\n      'Content-Type: application/json',\n      'Travis-API-Version: 3',\n      'Authorization:token '.$token,\n      'Content-Length:' . strlen($post_data)\n    );\n    curl_setopt($curl, CURLOPT_HTTPHEADER, $header);\n    curl_setopt($curl, CURLOPT_POSTFIELDS, $post_data);\n    //执行命令\n    $data = curl_exec($curl);\n    $info = curl_getinfo($curl);\n    //关闭URL请求\n    curl_close($curl);\n    return $info;\n}\n?>\n\n```\n\n\n这里有几个需要获取的参数：\n\n- travis登录token，在travis-ci.org 中设置界面获取：\n\n![image.png](https://cdn.nlark.com/yuque/0/2019/png/155457/1546854976464-f57b5676-57a6-45d6-a15f-a6ea73b5ea03.png#align=left&display=inline&height=719&name=image.png&originHeight=791&originWidth=1086&size=76663&width=987)\n\n- 仓库ID 或 扩展名，\n\n使用findder 或者 postman 发起一个请求： [https://api.travis-ci.org/owner/Ghostdar/repos](https://api.travis-ci.org/owner/Ghostdar/repos)\n\n![image.png](https://cdn.nlark.com/yuque/0/2019/png/155457/1547631371281-33ec82df-c47d-4036-9f5f-2a1a8cdd4a1e.png#align=left&display=inline&height=258&name=image.png&originHeight=284&originWidth=650&size=14791&width=591)<br />回包中可以获取到ID 和 slug。\n\n<a name=\"ed64f615\"></a>\n##### 3） 配置触发方式\n![image.png](https://cdn.nlark.com/yuque/0/2019/png/155457/1546855590231-653629dc-6c95-4c63-838a-cf17157c3174.png#align=left&display=inline&height=670&name=image.png&originHeight=737&originWidth=1446&size=64764&width=1315)\n\n一般会得到这么个api：<br />https://service-s08f6nvk-1251833201.ap-guangzhou.apigateway.myqcloud.com/release/xxx\n\n<a name=\"e7e83e9c\"></a>\n#### 3. 语雀配置\n配置一个仓库的webhook:<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/155457/1546855687662-f145f491-ef19-45f6-b30e-d422f693e29e.png#align=left&display=inline&height=525&name=image.png&originHeight=578&originWidth=1495&size=59624&width=1359)\n\n可以选择所有更新触发或者主动触发，主动触发的意思即发布需要勾选一个选项才会触发webhook。具体可参见语雀文档：[https://www.yuque.com/yuque/developer/doc-webhook](https://www.yuque.com/yuque/developer/doc-webhook)；<br />将serverless生成的api填入,可以在链接后面带参数：\n\n```\ntoken 登录token\nrepos 仓库id\nmessage 提交信息\nbranch 分支\n\n示例：\nhttps://service-s08f6nvk-1251833201.ap-guangzhou.apigateway.myqcloud.com/release/xxx?repos=xxx&token=xxx&message=xxx&branch=xxx\n\n```\n\n如果不在链接带参数则写在serverless函数内。\n\n<a name=\"9be39f08\"></a>\n#### 4. 开始发布或更新一篇文章\n\n发布或者更新一篇文章后，我们前往travis-ci,可以看到已经触发了一次构建请求：\n\n![image.png](https://cdn.nlark.com/yuque/0/2019/png/155457/1546860747403-da6d62e7-2655-42a8-88a0-48a065cbbdbe.png#align=left&display=inline&height=419&name=image.png&originHeight=461&originWidth=1560&size=83334&width=1418)<br />构建完成后，咱们的博客上已经妥妥的展示出来拉~<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/155457/1546860840760-f0b7e7b1-6f40-41e1-a7d0-57eaacf9da8f.png#align=left&display=inline&height=835&name=image.png&originHeight=918&originWidth=1765&size=136586&width=1605)\n\n附上博客地址：[https://ghostdar.github.io/](https://ghostdar.github.io/) ，羞耻的求个star~\n\n![image.jpeg](https://cdn.nlark.com/yuque/0/2019/jpeg/155457/1546857203402-ff98e92e-d34a-48c9-8c4c-8bb709756cc8.jpeg#align=left&display=inline&height=230&name=image.jpeg&originHeight=230&originWidth=219&size=5140&width=219)\n\n\n<a name=\"ba840b8b\"></a>\n### 三、其他的思路\n<a name=\"bcd59cc8\"></a>\n#### 1. github api \n可以使用github 的 api ，每当更新文章，自动生成一个commit ，触发travis-ci 构建，但是感觉工作量很大，就放弃了~\n<a name=\"87010e8a\"></a>\n#### 2. 有待挖掘的travis-ci \n目前我使用的方法是trigger a build ，其实可以做到更多的 自定义配置~为啥不研究？主要是我懒~<br />当然，如果有更好的方案也欢迎交流~\n<a name=\"115be720\"></a>\n##### 最后：\n再次感谢语雀开发webhook，以及@尹挚 大神的yuque-hexo插件~<br />附上地址：\n\n- yuque-hexo: [https://github.com/x-cold/yuque-hexo](https://github.com/x-cold/yuque-hexo)\n- yuque-blog: [https://github.com/x-cold/yuque-blog](https://github.com/x-cold/yuque-blog)\n",
    "body_draft": "",
    "body_html": "<p>tags: [hexo, node]</p><p>categories: 前端</p><hr /><p>Hexo + Github + 语雀 + yuque-hexo +travis-ci+severless 打造全自动持续集成个人博客，云端写作，自动部署，完美体验~</p><p>&lt;!-- more --&gt;</p><h3 id=\"b740fe7a\">一、Hexo+Github 的痛点</h3><h4 id=\"10a80c20\">1.为啥要用hexo+github？</h4><p>作为一个程序猿，博客肯定是必须要有的拉，github也是必须要混的拉~所以:</p><ul><li>hexo + github = 高大上</li></ul><p><img alt=\"image.jpeg\" title=\"image.jpeg\" src=\"https://cdn.nlark.com/yuque/0/2019/jpeg/155457/1546857679810-d82e3d46-e960-419c-a715-0a82c48a2fd6.jpeg#align=left&amp;display=inline&amp;height=225&amp;name=image.jpeg&amp;originHeight=225&amp;originWidth=225&amp;size=6267&amp;width=225\" style=\"max-width: 600px; width: 225px;\" /></p><p><br /></p><p><br /></p><h4 id=\"e29fe75d\">2.蛋疼的写作体验</h4><p>使用hexo，会面临如下问题：</p><ul><li>博客源码怎么管理？</li><li>图片存在哪？</li><li>如何编写markdown文件？</li></ul><p>相信很多人都在使用本地编辑器来写博客，那体验，真心蛋疼，比如说vscode，可视化插件一般般，图片还不能复制黏贴，想插入个图片还要先保存成文件放在本地，然后再引用，啥？你说七牛云存储？哪有复制黏贴爽呀~</p><p>当然，博客源码可以使用travis-ci 来做持续集成，想写博客或者换个电脑，clone一下源仓库，写完push一下，就可以不用管了。but，比起独立站点的博客，如wordpress，还是觉得写作体验有点不爽。</p><p><img alt=\"image.jpeg\" title=\"image.jpeg\" src=\"https://cdn.nlark.com/yuque/0/2019/jpeg/155457/1546858156666-f3f7ae20-c7f8-49b9-849d-b4364f3685f7.jpeg#align=left&amp;display=inline&amp;height=213&amp;name=image.jpeg&amp;originHeight=213&amp;originWidth=237&amp;size=5810&amp;width=237\" style=\"max-width: 600px; width: 237px;\" /></p><h4 id=\"a1cea4a7\">3. 脑洞大开：</h4><p>偶然间，朋友安利了语雀这个文档写作平台，觉得这就是完美的写作体验，各种UI和编辑器都很舒服~秀个图：</p><p><img alt=\"image.png\" title=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/155457/1546858295510-9ca72eb5-b3ae-4d7c-8478-d8d1cda959d0.png#align=left&amp;display=inline&amp;height=821&amp;name=image.png&amp;originHeight=903&amp;originWidth=1789&amp;size=119669&amp;width=1626\" style=\"max-width: 600px; width: 1626px;\" /></p><p><br /></p><p>markdown编辑器也是巨爽：</p><p><img alt=\"image.png\" title=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/155457/1546858354478-127bd82a-7958-40ce-b760-07e469bd55ba.png#align=left&amp;display=inline&amp;height=840&amp;name=image.png&amp;originHeight=924&amp;originWidth=1890&amp;size=125288&amp;width=1718\" style=\"max-width: 600px; width: 1718px;\" /></p><p><br /></p><p>于是乎，就在想能不能在语雀里写作，写完之后自动同步到Github的博客呢？年轻就要有激情，说干就干，花了一天时间，结合了severless、yuque-hexo、travis-ci之后，终于跑通了整个写作、发布、自动部署的流程~</p><p><img alt=\"image.jpeg\" title=\"image.jpeg\" src=\"https://cdn.nlark.com/yuque/0/2019/jpeg/155457/1546858544992-c921de6f-b08a-469a-bd5f-81996309443b.jpeg#align=left&amp;display=inline&amp;height=225&amp;name=image.jpeg&amp;originHeight=225&amp;originWidth=225&amp;size=10511&amp;width=225\" style=\"max-width: 600px; width: 225px;\" /></p><h3 id=\"62b46819\">二、具体方案</h3><p style=\"text-indent: 2em;\">整体流程：</p><p><img alt=\"工作流.png\" title=\"工作流.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/155457/1546854780929-79a8a0f2-1678-4e16-bf23-52bbc364a5eb.png#align=left&amp;display=inline&amp;height=262&amp;name=%E5%B7%A5%E4%BD%9C%E6%B5%81.png&amp;originHeight=446&amp;originWidth=1268&amp;size=21932&amp;width=746\" style=\"max-width: 600px; width: 746px;\" /></p><ul data-lake-indent=\"1\"><li>语雀发布一篇文章</li><li>webhook调用serverless函数</li><li>serverless 发起请求 trigger 一个 build 任务</li><li>travis-ci 同步语雀文章并构建hexo</li><li>github 生成静态页面展示</li></ul><h4 id=\"8072e205\">1. hexo+github+triavs-ci</h4><p>hexo如何部署，如何集成travis-ci，等等，我就不再讲了，网上类似的文章灰常多~</p><p>比如：</p><ul><li><a href=\"https://segmentfault.com/a/1190000013266001\" target=\"_blank\"></a><a href=\"https://segmentfault.com/a/1190000013266001\" target=\"_blank\">使用Hexo+Github+TravisCI搭建自动发布的静态博客系统</a></li><li><a href=\"https://segmentfault.com/a/1190000016487753\" target=\"_blank\"></a><a href=\"https://segmentfault.com/a/1190000016487753\" target=\"_blank\">GitHub pages + Hexo 搭建自己的个人博客</a></li></ul><p><img alt=\"image.png\" title=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/155457/1546856496741-e2bcacb7-133f-411f-8696-68e29c280dfc.png#align=left&amp;display=inline&amp;height=225&amp;name=image.png&amp;originHeight=225&amp;originWidth=225&amp;size=3779&amp;width=225\" style=\"max-width: 600px; width: 225px;\" /></p><p><br /></p><p>那么如何同步语雀的文章呢？答案就是：</p><h5 id=\"yuque-hexo\">yuque-hexo</h5><p>这是一个开源库：<a href=\"https://github.com/x-cold/yuque-hexo\" target=\"_blank\">https://github.com/x-cold/yuque-hexo</a></p><p>用法也很简单：</p><p>1) 修改package.json，增加配置:</p><p><br /></p><pre data-lang=\"json\"><code>  &quot;yuqueConfig&quot;: {\n    &quot;baseUrl&quot;: &quot;https://www.yuque.com/api/v2&quot;,\n    &quot;login&quot;: &quot;u46795&quot;,\n    &quot;repo&quot;: &quot;blog&quot;,\n    &quot;mdNameFormat&quot;: &quot;title&quot;,\n    &quot;postPath&quot;: &quot;source/_posts/yuque&quot;\n  },</code></pre><p>2）增加命令：</p><p><br /></p><pre data-lang=\"json\"><code>  &quot;scripts&quot;: {\n    &quot;sync&quot;: &quot;yuque-hexo sync&quot;,\n    &quot;clean:yuque&quot;: &quot;yuque-hexo clean&quot;,\n    &quot;deploy&quot;: &quot;npm run sync &amp;&amp; hexo clean &amp;&amp; hexo g -d&quot;,\n  },</code></pre><p><br /></p><p>附上我的<a href=\"https://github.com/Ghostdar/blog-origin/blob/master/package.json\" target=\"_blank\">package.json</a>文件。</p><h4 id=\"2db9be93\">2. serverless</h4><p>目前阿里云和腾讯云都有serverless服务，免费的额度完全够用了，下面介绍一下如何配置：</p><h5 id=\"cd59a2fd\">1）创建函数</h5><p><img alt=\"image.png\" title=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/155457/1546855514908-08a6c588-774a-404e-8425-89ce6a3f7167.png#align=left&amp;display=inline&amp;height=697&amp;name=image.png&amp;originHeight=767&amp;originWidth=1408&amp;size=90789&amp;width=1280\" style=\"max-width: 600px; width: 1280px;\" /></p><h5 id=\"7fffeff3\">2）serverless 函数示例:</h5><p><br /></p><pre data-lang=\"php\"><code>&lt;?php\nfunction main_handler($event, $context) {\n    // 解析语雀post的数据\n    $update_title = '';\n    if($event-&gt;body){\n        $yuque_data= json_decode($event-&gt;body);\n        $update_title .= $yuque_data-&gt;data-&gt;title;\n    }\n    // default params\n    $repos = 'xxxx';  // 你的仓库id 或 slug\n    $token = 'xxxxxx'; // 你的登录token\n    $message = date(&quot;Y/m/d&quot;).':yuque update:'.$update_title;\n    $branch = 'master';\n    // post params\n    $queryString = $event-&gt;queryString;\n    $q_token = $queryString-&gt;token ? $queryString-&gt;token : $token;\n    $q_repos = $queryString-&gt;repos ? $queryString-&gt;repos : $repos;\n    $q_message = $queryString-&gt;message ? $queryString-&gt;message : $message;\n    $q_branch = $queryString-&gt;branch ? $queryString-&gt;branch : 'master';\n    echo($q_token);\n    echo('===');\n    echo ($q_repos);\n    echo ('===');\n    echo ($q_message);\n    echo ('===');\n    echo ($q_branch);\n    echo ('===');\n    //request travis ci\n    $res_info = triggerTravisCI($q_repos, $q_token, $q_message, $q_branch);\n\n    $res_code = 0;\n    $res_message = '未知';\n    if($res_info['http_code']){\n        $res_code = $res_info['http_code'];\n        switch($res_info['http_code']){\n            case 200:\n            case 202:\n                $res_message = 'success';\n            break;\n            default:\n                $res_message = 'faild';\n            break;\n        }\n    }\n    $res = array(\n        'status'=&gt;$res_code,\n        'message'=&gt;$res_message\n    );\n    return $res;\n}\n\n/*\n* @description  travis api , trigger a build\n* @param $repos string 仓库ID、slug\n* @param $token string 登录验证token\n* @param $message string 触发信息\n* @param $branch string 分支\n* @return $info array 回包信息\n*/\nfunction triggerTravisCI ($repos, $token, $message='yuque update', $branch='master') {\n    //初始化\n    $curl = curl_init();\n    //设置抓取的url\n    curl_setopt($curl, CURLOPT_URL, 'https://api.travis-ci.org/repo/'.$repos.'/requests');\n    //设置获取的信息以文件流的形式返回，而不是直接输出。\n    curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);\n    //设置post方式提交\n    curl_setopt($curl, CURLOPT_CUSTOMREQUEST, &quot;POST&quot;);\n    //设置post数据\n    $post_data = json_encode(array(\n        &quot;request&quot;=&gt; array(\n            &quot;message&quot;=&gt;$message,\n            &quot;branch&quot;=&gt;$branch\n        )\n    ));\n    $header = array(\n      'Content-Type: application/json',\n      'Travis-API-Version: 3',\n      'Authorization:token '.$token,\n      'Content-Length:' . strlen($post_data)\n    );\n    curl_setopt($curl, CURLOPT_HTTPHEADER, $header);\n    curl_setopt($curl, CURLOPT_POSTFIELDS, $post_data);\n    //执行命令\n    $data = curl_exec($curl);\n    $info = curl_getinfo($curl);\n    //关闭URL请求\n    curl_close($curl);\n    return $info;\n}\n?&gt;\n</code></pre><p><br /></p><p><br /></p><p>这里有几个需要获取的参数：</p><ul><li>travis登录token，在travis-ci.org 中设置界面获取：</li></ul><p><img alt=\"image.png\" title=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/155457/1546854976464-f57b5676-57a6-45d6-a15f-a6ea73b5ea03.png#align=left&amp;display=inline&amp;height=719&amp;name=image.png&amp;originHeight=791&amp;originWidth=1086&amp;size=76663&amp;width=987\" style=\"max-width: 600px; width: 987px;\" /></p><p><br /></p><ul><li>仓库ID 或 扩展名，</li></ul><p><br /></p><p>使用findder 或者 postman 发起一个请求： <a href=\"https://api.travis-ci.org/owner/Ghostdar/repos\" target=\"_blank\">https://api.travis-ci.org/owner/Ghostdar/repos</a></p><p><br /></p><p><img alt=\"image.png\" title=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/155457/1547631371281-33ec82df-c47d-4036-9f5f-2a1a8cdd4a1e.png#align=left&amp;display=inline&amp;height=258&amp;name=image.png&amp;originHeight=284&amp;originWidth=650&amp;size=14791&amp;width=591\" style=\"max-width: 600px; width: 591px;\" /></p><p>回包中可以获取到ID 和 slug。</p><p><br /></p><h5 id=\"ed64f615\">3） 配置触发方式</h5><p><img alt=\"image.png\" title=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/155457/1546855590231-653629dc-6c95-4c63-838a-cf17157c3174.png#align=left&amp;display=inline&amp;height=670&amp;name=image.png&amp;originHeight=737&amp;originWidth=1446&amp;size=64764&amp;width=1315\" style=\"max-width: 600px; width: 1315px;\" /></p><p><br /></p><p>一般会得到这么个api：</p><p>https://service-s08f6nvk-1251833201.ap-guangzhou.apigateway.myqcloud.com/release/xxx</p><p><br /></p><h4 id=\"e7e83e9c\">3. 语雀配置</h4><p>配置一个仓库的webhook:</p><p><img alt=\"image.png\" title=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/155457/1546855687662-f145f491-ef19-45f6-b30e-d422f693e29e.png#align=left&amp;display=inline&amp;height=525&amp;name=image.png&amp;originHeight=578&amp;originWidth=1495&amp;size=59624&amp;width=1359\" style=\"max-width: 600px; width: 1359px;\" /></p><p><br /></p><p>可以选择所有更新触发或者主动触发，主动触发的意思即发布需要勾选一个选项才会触发webhook。具体可参见语雀文档：<a href=\"https://www.yuque.com/yuque/developer/doc-webhook\" target=\"_blank\">https://www.yuque.com/yuque/developer/doc-webhook</a>；</p><p>将serverless生成的api填入,可以在链接后面带参数：</p><p><br /></p><pre><code>token 登录token\nrepos 仓库id\nmessage 提交信息\nbranch 分支\n\n示例：\nhttps://service-s08f6nvk-1251833201.ap-guangzhou.apigateway.myqcloud.com/release/xxx?repos=xxx&amp;token=xxx&amp;message=xxx&amp;branch=xxx\n</code></pre><p><br /></p><p>如果不在链接带参数则写在serverless函数内。</p><p><br /></p><h4 id=\"9be39f08\">4. 开始发布或更新一篇文章</h4><p><br /></p><p>发布或者更新一篇文章后，我们前往travis-ci,可以看到已经触发了一次构建请求：</p><p><br /></p><p><img alt=\"image.png\" title=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/155457/1546860747403-da6d62e7-2655-42a8-88a0-48a065cbbdbe.png#align=left&amp;display=inline&amp;height=419&amp;name=image.png&amp;originHeight=461&amp;originWidth=1560&amp;size=83334&amp;width=1418\" style=\"max-width: 600px; width: 1418px;\" /></p><p>构建完成后，咱们的博客上已经妥妥的展示出来拉~</p><p><img alt=\"image.png\" title=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/155457/1546860840760-f0b7e7b1-6f40-41e1-a7d0-57eaacf9da8f.png#align=left&amp;display=inline&amp;height=835&amp;name=image.png&amp;originHeight=918&amp;originWidth=1765&amp;size=136586&amp;width=1605\" style=\"max-width: 600px; width: 1605px;\" /></p><p><br /></p><p>附上博客地址：<a href=\"https://ghostdar.github.io/\" target=\"_blank\">https://ghostdar.github.io/</a> ，羞耻的求个star~</p><p><br /></p><p><img alt=\"image.jpeg\" title=\"image.jpeg\" src=\"https://cdn.nlark.com/yuque/0/2019/jpeg/155457/1546857203402-ff98e92e-d34a-48c9-8c4c-8bb709756cc8.jpeg#align=left&amp;display=inline&amp;height=230&amp;name=image.jpeg&amp;originHeight=230&amp;originWidth=219&amp;size=5140&amp;width=219\" style=\"max-width: 600px; width: 219px;\" /></p><p><br /></p><p><br /></p><h3 id=\"ba840b8b\">三、其他的思路</h3><h4 id=\"bcd59cc8\">1. github api </h4><p>可以使用github 的 api ，每当更新文章，自动生成一个commit ，触发travis-ci 构建，但是感觉工作量很大，就放弃了~</p><h4 id=\"87010e8a\">2. 有待挖掘的travis-ci </h4><p>目前我使用的方法是trigger a build ，其实可以做到更多的 自定义配置~为啥不研究？主要是我懒~</p><p>当然，如果有更好的方案也欢迎交流~</p><h5 id=\"115be720\">最后：</h5><p>再次感谢语雀开发webhook，以及@尹挚 大神的yuque-hexo插件~</p><p>附上地址：</p><ul><li>yuque-hexo: <a href=\"https://github.com/x-cold/yuque-hexo\" target=\"_blank\">https://github.com/x-cold/yuque-hexo</a></li><li>yuque-blog: <a href=\"https://github.com/x-cold/yuque-blog\" target=\"_blank\">https://github.com/x-cold/yuque-blog</a></li></ul>",
    "body_lake": "<!doctype lake><p>tags: [hexo, node]</p><p>categories: 前端</p><card type=\"block\" name=\"hr\"></card><p>Hexo + Github + 语雀 + yuque-hexo +travis-ci+severless 打造全自动持续集成个人博客，云端写作，自动部署，完美体验~</p><p>&lt;!-- more --&gt;</p><h3 id=\"b740fe7a\">一、Hexo+Github 的痛点</h3><h4 id=\"10a80c20\">1.为啥要用hexo+github？</h4><p>作为一个程序猿，博客肯定是必须要有的拉，github也是必须要混的拉~所以:</p><ul><li>hexo + github = 高大上</li></ul><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fjpeg%2F155457%2F1546857679810-d82e3d46-e960-419c-a715-0a82c48a2fd6.jpeg%22%2C%22originWidth%22%3A225%2C%22originHeight%22%3A225%2C%22name%22%3A%22image.jpeg%22%2C%22size%22%3A6267%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22width%22%3A225%2C%22height%22%3A225%7D\"></card></p><p><br /></p><p><br /></p><h4 id=\"e29fe75d\">2.蛋疼的写作体验</h4><p>使用hexo，会面临如下问题：</p><ul><li>博客源码怎么管理？</li><li>图片存在哪？</li><li>如何编写markdown文件？</li></ul><p>相信很多人都在使用本地编辑器来写博客，那体验，真心蛋疼，比如说vscode，可视化插件一般般，图片还不能复制黏贴，想插入个图片还要先保存成文件放在本地，然后再引用，啥？你说七牛云存储？哪有复制黏贴爽呀~</p><p>当然，博客源码可以使用travis-ci 来做持续集成，想写博客或者换个电脑，clone一下源仓库，写完push一下，就可以不用管了。but，比起独立站点的博客，如wordpress，还是觉得写作体验有点不爽。</p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fjpeg%2F155457%2F1546858156666-f3f7ae20-c7f8-49b9-849d-b4364f3685f7.jpeg%22%2C%22originWidth%22%3A237%2C%22originHeight%22%3A213%2C%22name%22%3A%22image.jpeg%22%2C%22size%22%3A5810%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22width%22%3A237%2C%22height%22%3A213%7D\"></card></p><h4 id=\"a1cea4a7\">3. 脑洞大开：</h4><p>偶然间，朋友安利了语雀这个文档写作平台，觉得这就是完美的写作体验，各种UI和编辑器都很舒服~秀个图：</p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F155457%2F1546858295510-9ca72eb5-b3ae-4d7c-8478-d8d1cda959d0.png%22%2C%22originWidth%22%3A1789%2C%22originHeight%22%3A903%2C%22name%22%3A%22image.png%22%2C%22size%22%3A119669%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22width%22%3A1626%2C%22height%22%3A821%7D\"></card></p><p><br /></p><p>markdown编辑器也是巨爽：</p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F155457%2F1546858354478-127bd82a-7958-40ce-b760-07e469bd55ba.png%22%2C%22originWidth%22%3A1890%2C%22originHeight%22%3A924%2C%22name%22%3A%22image.png%22%2C%22size%22%3A125288%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22width%22%3A1718%2C%22height%22%3A840%7D\"></card></p><p><br /></p><p>于是乎，就在想能不能在语雀里写作，写完之后自动同步到Github的博客呢？年轻就要有激情，说干就干，花了一天时间，结合了severless、yuque-hexo、travis-ci之后，终于跑通了整个写作、发布、自动部署的流程~</p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fjpeg%2F155457%2F1546858544992-c921de6f-b08a-469a-bd5f-81996309443b.jpeg%22%2C%22originWidth%22%3A225%2C%22originHeight%22%3A225%2C%22name%22%3A%22image.jpeg%22%2C%22size%22%3A10511%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22width%22%3A225%2C%22height%22%3A225%7D\"></card></p><h3 id=\"62b46819\">二、具体方案</h3><p style=\"text-indent: 2em;\">整体流程：</p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F155457%2F1546854780929-79a8a0f2-1678-4e16-bf23-52bbc364a5eb.png%22%2C%22originWidth%22%3A1268%2C%22originHeight%22%3A446%2C%22name%22%3A%22%E5%B7%A5%E4%BD%9C%E6%B5%81.png%22%2C%22size%22%3A21932%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22width%22%3A746%2C%22height%22%3A262%7D\"></card></p><ul data-lake-indent=\"1\"><li>语雀发布一篇文章</li><li>webhook调用serverless函数</li><li>serverless 发起请求 trigger 一个 build 任务</li><li>travis-ci 同步语雀文章并构建hexo</li><li>github 生成静态页面展示</li></ul><h4 id=\"8072e205\">1. hexo+github+triavs-ci</h4><p>hexo如何部署，如何集成travis-ci，等等，我就不再讲了，网上类似的文章灰常多~</p><p>比如：</p><ul><li><a href=\"https://segmentfault.com/a/1190000013266001\" target=\"_blank\"></a><a href=\"https://segmentfault.com/a/1190000013266001\" target=\"_blank\">使用Hexo+Github+TravisCI搭建自动发布的静态博客系统</a></li><li><a href=\"https://segmentfault.com/a/1190000016487753\" target=\"_blank\"></a><a href=\"https://segmentfault.com/a/1190000016487753\" target=\"_blank\">GitHub pages + Hexo 搭建自己的个人博客</a></li></ul><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F155457%2F1546856496741-e2bcacb7-133f-411f-8696-68e29c280dfc.png%22%2C%22originWidth%22%3A225%2C%22originHeight%22%3A225%2C%22name%22%3A%22image.png%22%2C%22size%22%3A3779%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22width%22%3A225%2C%22height%22%3A225%7D\"></card></p><p><br /></p><p>那么如何同步语雀的文章呢？答案就是：</p><h5 id=\"yuque-hexo\">yuque-hexo</h5><p>这是一个开源库：<a href=\"https://github.com/x-cold/yuque-hexo\" target=\"_blank\">https://github.com/x-cold/yuque-hexo</a></p><p>用法也很简单：</p><p>1) 修改package.json，增加配置:</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22json%22%2C%22code%22%3A%22%20%20%5C%22yuqueConfig%5C%22%3A%20%7B%5Cn%20%20%20%20%5C%22baseUrl%5C%22%3A%20%5C%22https%3A%2F%2Fwww.yuque.com%2Fapi%2Fv2%5C%22%2C%5Cn%20%20%20%20%5C%22login%5C%22%3A%20%5C%22u46795%5C%22%2C%5Cn%20%20%20%20%5C%22repo%5C%22%3A%20%5C%22blog%5C%22%2C%5Cn%20%20%20%20%5C%22mdNameFormat%5C%22%3A%20%5C%22title%5C%22%2C%5Cn%20%20%20%20%5C%22postPath%5C%22%3A%20%5C%22source%2F_posts%2Fyuque%5C%22%5Cn%20%20%7D%2C%22%7D\"></card><p>2）增加命令：</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22json%22%2C%22code%22%3A%22%20%20%5C%22scripts%5C%22%3A%20%7B%5Cn%20%20%20%20%5C%22sync%5C%22%3A%20%5C%22yuque-hexo%20sync%5C%22%2C%5Cn%20%20%20%20%5C%22clean%3Ayuque%5C%22%3A%20%5C%22yuque-hexo%20clean%5C%22%2C%5Cn%20%20%20%20%5C%22deploy%5C%22%3A%20%5C%22npm%20run%20sync%20%26%26%20hexo%20clean%20%26%26%20hexo%20g%20-d%5C%22%2C%5Cn%20%20%7D%2C%22%7D\"></card><p><br /></p><p>附上我的<a href=\"https://github.com/Ghostdar/blog-origin/blob/master/package.json\" target=\"_blank\">package.json</a>文件。</p><h4 id=\"2db9be93\">2. serverless</h4><p>目前阿里云和腾讯云都有serverless服务，免费的额度完全够用了，下面介绍一下如何配置：</p><h5 id=\"cd59a2fd\">1）创建函数</h5><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F155457%2F1546855514908-08a6c588-774a-404e-8425-89ce6a3f7167.png%22%2C%22originWidth%22%3A1408%2C%22originHeight%22%3A767%2C%22name%22%3A%22image.png%22%2C%22size%22%3A90789%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22width%22%3A1280%2C%22height%22%3A697%7D\"></card></p><h5 id=\"7fffeff3\">2）serverless 函数示例:</h5><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22php%22%2C%22code%22%3A%22%3C%3Fphp%5Cnfunction%20main_handler(%24event%2C%20%24context)%20%7B%5Cn%20%20%20%20%2F%2F%20%E8%A7%A3%E6%9E%90%E8%AF%AD%E9%9B%80post%E7%9A%84%E6%95%B0%E6%8D%AE%5Cn%20%20%20%20%24update_title%20%3D%20''%3B%5Cn%20%20%20%20if(%24event-%3Ebody)%7B%5Cn%20%20%20%20%20%20%20%20%24yuque_data%3D%20json_decode(%24event-%3Ebody)%3B%5Cn%20%20%20%20%20%20%20%20%24update_title%20.%3D%20%24yuque_data-%3Edata-%3Etitle%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20%2F%2F%20default%20params%5Cn%20%20%20%20%24repos%20%3D%20'xxxx'%3B%20%20%2F%2F%20%E4%BD%A0%E7%9A%84%E4%BB%93%E5%BA%93id%20%E6%88%96%20slug%5Cn%20%20%20%20%24token%20%3D%20'xxxxxx'%3B%20%2F%2F%20%E4%BD%A0%E7%9A%84%E7%99%BB%E5%BD%95token%5Cn%20%20%20%20%24message%20%3D%20date(%5C%22Y%2Fm%2Fd%5C%22).'%3Ayuque%20update%3A'.%24update_title%3B%5Cn%20%20%20%20%24branch%20%3D%20'master'%3B%5Cn%20%20%20%20%2F%2F%20post%20params%5Cn%20%20%20%20%24queryString%20%3D%20%24event-%3EqueryString%3B%5Cn%20%20%20%20%24q_token%20%3D%20%24queryString-%3Etoken%20%3F%20%24queryString-%3Etoken%20%3A%20%24token%3B%5Cn%20%20%20%20%24q_repos%20%3D%20%24queryString-%3Erepos%20%3F%20%24queryString-%3Erepos%20%3A%20%24repos%3B%5Cn%20%20%20%20%24q_message%20%3D%20%24queryString-%3Emessage%20%3F%20%24queryString-%3Emessage%20%3A%20%24message%3B%5Cn%20%20%20%20%24q_branch%20%3D%20%24queryString-%3Ebranch%20%3F%20%24queryString-%3Ebranch%20%3A%20'master'%3B%5Cn%20%20%20%20echo(%24q_token)%3B%5Cn%20%20%20%20echo('%3D%3D%3D')%3B%5Cn%20%20%20%20echo%20(%24q_repos)%3B%5Cn%20%20%20%20echo%20('%3D%3D%3D')%3B%5Cn%20%20%20%20echo%20(%24q_message)%3B%5Cn%20%20%20%20echo%20('%3D%3D%3D')%3B%5Cn%20%20%20%20echo%20(%24q_branch)%3B%5Cn%20%20%20%20echo%20('%3D%3D%3D')%3B%5Cn%20%20%20%20%2F%2Frequest%20travis%20ci%5Cn%20%20%20%20%24res_info%20%3D%20triggerTravisCI(%24q_repos%2C%20%24q_token%2C%20%24q_message%2C%20%24q_branch)%3B%5Cn%5Cn%20%20%20%20%24res_code%20%3D%200%3B%5Cn%20%20%20%20%24res_message%20%3D%20'%E6%9C%AA%E7%9F%A5'%3B%5Cn%20%20%20%20if(%24res_info%5B'http_code'%5D)%7B%5Cn%20%20%20%20%20%20%20%20%24res_code%20%3D%20%24res_info%5B'http_code'%5D%3B%5Cn%20%20%20%20%20%20%20%20switch(%24res_info%5B'http_code'%5D)%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20case%20200%3A%5Cn%20%20%20%20%20%20%20%20%20%20%20%20case%20202%3A%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%24res_message%20%3D%20'success'%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20break%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20default%3A%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%24res_message%20%3D%20'faild'%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20break%3B%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%20%20%20%20%24res%20%3D%20array(%5Cn%20%20%20%20%20%20%20%20'status'%3D%3E%24res_code%2C%5Cn%20%20%20%20%20%20%20%20'message'%3D%3E%24res_message%5Cn%20%20%20%20)%3B%5Cn%20%20%20%20return%20%24res%3B%5Cn%7D%5Cn%5Cn%2F*%5Cn*%20%40description%20%20travis%20api%20%2C%20trigger%20a%20build%5Cn*%20%40param%20%24repos%20string%20%E4%BB%93%E5%BA%93ID%E3%80%81slug%5Cn*%20%40param%20%24token%20string%20%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81token%5Cn*%20%40param%20%24message%20string%20%E8%A7%A6%E5%8F%91%E4%BF%A1%E6%81%AF%5Cn*%20%40param%20%24branch%20string%20%E5%88%86%E6%94%AF%5Cn*%20%40return%20%24info%20array%20%E5%9B%9E%E5%8C%85%E4%BF%A1%E6%81%AF%5Cn*%2F%5Cnfunction%20triggerTravisCI%20(%24repos%2C%20%24token%2C%20%24message%3D'yuque%20update'%2C%20%24branch%3D'master')%20%7B%5Cn%20%20%20%20%2F%2F%E5%88%9D%E5%A7%8B%E5%8C%96%5Cn%20%20%20%20%24curl%20%3D%20curl_init()%3B%5Cn%20%20%20%20%2F%2F%E8%AE%BE%E7%BD%AE%E6%8A%93%E5%8F%96%E7%9A%84url%5Cn%20%20%20%20curl_setopt(%24curl%2C%20CURLOPT_URL%2C%20'https%3A%2F%2Fapi.travis-ci.org%2Frepo%2F'.%24repos.'%2Frequests')%3B%5Cn%20%20%20%20%2F%2F%E8%AE%BE%E7%BD%AE%E8%8E%B7%E5%8F%96%E7%9A%84%E4%BF%A1%E6%81%AF%E4%BB%A5%E6%96%87%E4%BB%B6%E6%B5%81%E7%9A%84%E5%BD%A2%E5%BC%8F%E8%BF%94%E5%9B%9E%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E7%9B%B4%E6%8E%A5%E8%BE%93%E5%87%BA%E3%80%82%5Cn%20%20%20%20curl_setopt(%24curl%2C%20CURLOPT_RETURNTRANSFER%2C%201)%3B%5Cn%20%20%20%20%2F%2F%E8%AE%BE%E7%BD%AEpost%E6%96%B9%E5%BC%8F%E6%8F%90%E4%BA%A4%5Cn%20%20%20%20curl_setopt(%24curl%2C%20CURLOPT_CUSTOMREQUEST%2C%20%5C%22POST%5C%22)%3B%5Cn%20%20%20%20%2F%2F%E8%AE%BE%E7%BD%AEpost%E6%95%B0%E6%8D%AE%5Cn%20%20%20%20%24post_data%20%3D%20json_encode(array(%5Cn%20%20%20%20%20%20%20%20%5C%22request%5C%22%3D%3E%20array(%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%5C%22message%5C%22%3D%3E%24message%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%5C%22branch%5C%22%3D%3E%24branch%5Cn%20%20%20%20%20%20%20%20)%5Cn%20%20%20%20))%3B%5Cn%20%20%20%20%24header%20%3D%20array(%5Cn%20%20%20%20%20%20'Content-Type%3A%20application%2Fjson'%2C%5Cn%20%20%20%20%20%20'Travis-API-Version%3A%203'%2C%5Cn%20%20%20%20%20%20'Authorization%3Atoken%20'.%24token%2C%5Cn%20%20%20%20%20%20'Content-Length%3A'%20.%20strlen(%24post_data)%5Cn%20%20%20%20)%3B%5Cn%20%20%20%20curl_setopt(%24curl%2C%20CURLOPT_HTTPHEADER%2C%20%24header)%3B%5Cn%20%20%20%20curl_setopt(%24curl%2C%20CURLOPT_POSTFIELDS%2C%20%24post_data)%3B%5Cn%20%20%20%20%2F%2F%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%5Cn%20%20%20%20%24data%20%3D%20curl_exec(%24curl)%3B%5Cn%20%20%20%20%24info%20%3D%20curl_getinfo(%24curl)%3B%5Cn%20%20%20%20%2F%2F%E5%85%B3%E9%97%ADURL%E8%AF%B7%E6%B1%82%5Cn%20%20%20%20curl_close(%24curl)%3B%5Cn%20%20%20%20return%20%24info%3B%5Cn%7D%5Cn%3F%3E%5Cn%22%7D\"></card><p><br /></p><p><br /></p><p>这里有几个需要获取的参数：</p><ul><li>travis登录token，在travis-ci.org 中设置界面获取：</li></ul><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F155457%2F1546854976464-f57b5676-57a6-45d6-a15f-a6ea73b5ea03.png%22%2C%22originWidth%22%3A1086%2C%22originHeight%22%3A791%2C%22name%22%3A%22image.png%22%2C%22size%22%3A76663%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22width%22%3A987%2C%22height%22%3A719%7D\"></card></p><p><br /></p><ul><li>仓库ID 或 扩展名，</li></ul><p><br /></p><p>使用findder 或者 postman 发起一个请求： <a href=\"https://api.travis-ci.org/owner/Ghostdar/repos\" target=\"_blank\">https://api.travis-ci.org/owner/Ghostdar/repos</a></p><p><br /></p><p><cursor /><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F155457%2F1547631371281-33ec82df-c47d-4036-9f5f-2a1a8cdd4a1e.png%22%2C%22originWidth%22%3A650%2C%22originHeight%22%3A284%2C%22name%22%3A%22image.png%22%2C%22size%22%3A14791%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22width%22%3A591%2C%22height%22%3A258%7D\"></card></p><p>回包中可以获取到ID 和 slug。</p><p><br /></p><h5 id=\"ed64f615\">3） 配置触发方式</h5><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F155457%2F1546855590231-653629dc-6c95-4c63-838a-cf17157c3174.png%22%2C%22originWidth%22%3A1446%2C%22originHeight%22%3A737%2C%22name%22%3A%22image.png%22%2C%22size%22%3A64764%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22width%22%3A1315%2C%22height%22%3A670%7D\"></card></p><p><br /></p><p>一般会得到这么个api：</p><p>https://service-s08f6nvk-1251833201.ap-guangzhou.apigateway.myqcloud.com/release/xxx</p><p><br /></p><h4 id=\"e7e83e9c\">3. 语雀配置</h4><p>配置一个仓库的webhook:</p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F155457%2F1546855687662-f145f491-ef19-45f6-b30e-d422f693e29e.png%22%2C%22originWidth%22%3A1495%2C%22originHeight%22%3A578%2C%22name%22%3A%22image.png%22%2C%22size%22%3A59624%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22width%22%3A1359%2C%22height%22%3A525%7D\"></card></p><p><br /></p><p>可以选择所有更新触发或者主动触发，主动触发的意思即发布需要勾选一个选项才会触发webhook。具体可参见语雀文档：<a href=\"https://www.yuque.com/yuque/developer/doc-webhook\" target=\"_blank\">https://www.yuque.com/yuque/developer/doc-webhook</a>；</p><p>将serverless生成的api填入,可以在链接后面带参数：</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22plain%22%2C%22code%22%3A%22token%20%E7%99%BB%E5%BD%95token%5Cnrepos%20%E4%BB%93%E5%BA%93id%5Cnmessage%20%E6%8F%90%E4%BA%A4%E4%BF%A1%E6%81%AF%5Cnbranch%20%E5%88%86%E6%94%AF%5Cn%5Cn%E7%A4%BA%E4%BE%8B%EF%BC%9A%5Cnhttps%3A%2F%2Fservice-s08f6nvk-1251833201.ap-guangzhou.apigateway.myqcloud.com%2Frelease%2Fxxx%3Frepos%3Dxxx%26token%3Dxxx%26message%3Dxxx%26branch%3Dxxx%5Cn%22%7D\"></card><p><br /></p><p>如果不在链接带参数则写在serverless函数内。</p><p><br /></p><h4 id=\"9be39f08\">4. 开始发布或更新一篇文章</h4><p><br /></p><p>发布或者更新一篇文章后，我们前往travis-ci,可以看到已经触发了一次构建请求：</p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F155457%2F1546860747403-da6d62e7-2655-42a8-88a0-48a065cbbdbe.png%22%2C%22originWidth%22%3A1560%2C%22originHeight%22%3A461%2C%22name%22%3A%22image.png%22%2C%22size%22%3A83334%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22width%22%3A1418%2C%22height%22%3A419%7D\"></card></p><p>构建完成后，咱们的博客上已经妥妥的展示出来拉~</p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F155457%2F1546860840760-f0b7e7b1-6f40-41e1-a7d0-57eaacf9da8f.png%22%2C%22originWidth%22%3A1765%2C%22originHeight%22%3A918%2C%22name%22%3A%22image.png%22%2C%22size%22%3A136586%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22width%22%3A1605%2C%22height%22%3A835%7D\"></card></p><p><br /></p><p>附上博客地址：<a href=\"https://ghostdar.github.io/\" target=\"_blank\">https://ghostdar.github.io/</a> ，羞耻的求个star~</p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fjpeg%2F155457%2F1546857203402-ff98e92e-d34a-48c9-8c4c-8bb709756cc8.jpeg%22%2C%22originWidth%22%3A219%2C%22originHeight%22%3A230%2C%22name%22%3A%22image.jpeg%22%2C%22size%22%3A5140%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22width%22%3A219%2C%22height%22%3A230%7D\"></card></p><p><br /></p><p><br /></p><h3 id=\"ba840b8b\">三、其他的思路</h3><h4 id=\"bcd59cc8\">1. github api </h4><p>可以使用github 的 api ，每当更新文章，自动生成一个commit ，触发travis-ci 构建，但是感觉工作量很大，就放弃了~</p><h4 id=\"87010e8a\">2. 有待挖掘的travis-ci </h4><p>目前我使用的方法是trigger a build ，其实可以做到更多的 自定义配置~为啥不研究？主要是我懒~</p><p>当然，如果有更好的方案也欢迎交流~</p><h5 id=\"115be720\">最后：</h5><p>再次感谢语雀开发webhook，以及@尹挚 大神的yuque-hexo插件~</p><p>附上地址：</p><ul><li>yuque-hexo: <a href=\"https://github.com/x-cold/yuque-hexo\" target=\"_blank\">https://github.com/x-cold/yuque-hexo</a></li><li>yuque-blog: <a href=\"https://github.com/x-cold/yuque-blog\" target=\"_blank\">https://github.com/x-cold/yuque-blog</a></li></ul>",
    "public": 1,
    "status": 1,
    "likes_count": 7,
    "comments_count": 14,
    "content_updated_at": "2019-01-16T09:36:22.000Z",
    "deleted_at": null,
    "created_at": "2019-01-07T09:29:59.000Z",
    "updated_at": "2019-05-20T02:33:45.000Z",
    "published_at": "2019-01-16T09:36:30.000Z",
    "first_published_at": "2019-01-07T10:31:03.000Z",
    "word_count": 1597,
    "cover": null,
    "description": "tags: [hexo, node]categories: 前端Hexo + Github + 语雀 + yuque-hexo +travis-ci+severless 打造全自动持续集成个人博客，云端写作，自动部署，完美体验~&lt;!-- more --&gt;一、Hexo+Github ...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1116540,
    "slug": "cgc4fh",
    "title": "浅析-Apache-工作原理",
    "book_id": 199054,
    "book": {
      "id": 199054,
      "type": "Book",
      "slug": "blog",
      "name": "博客",
      "user_id": 155457,
      "description": "前端技术博客存档",
      "creator_id": 155457,
      "public": 1,
      "items_count": 15,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-04-23T09:00:45.336Z",
      "updated_at": "2019-04-23T09:00:45.000Z",
      "created_at": "2019-01-06T05:57:32.000Z",
      "namespace": "u46795/blog",
      "user": {
        "id": 155457,
        "type": "User",
        "login": "u46795",
        "name": "Nero",
        "description": "https://github.com/Ghostdar",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 5,
        "public_books_count": 5,
        "followers_count": 12,
        "following_count": 5,
        "created_at": "2018-08-04T03:45:56.000Z",
        "updated_at": "2019-04-30T15:08:36.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 155457,
    "creator": {
      "id": 155457,
      "type": "User",
      "login": "u46795",
      "name": "Nero",
      "description": "https://github.com/Ghostdar",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 5,
      "public_books_count": 5,
      "followers_count": 12,
      "following_count": 5,
      "created_at": "2018-08-04T03:45:56.000Z",
      "updated_at": "2019-04-30T15:08:36.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "date: 2017-04-01 23:32:29<br />categories: '后端'<br />tags: ['Apache','web服务器','后端']\n\n---\n\nApache是目前世界上使用最为广泛的一种Web Server，它以跨平台、高效和稳定而闻名。那么Apache是怎样工作的呢？<br /><!-- more -->\n<a name=\"cee624d5\"></a>\n## 一、LAMP架构\n\n说起apache，那就不得不了解一下LAMP架构，LAMP架构是较为流行的一套建站架构，因其通用、跨平台、高性能、低价格的优势，无论是性能、质量还是价格都是企业搭建网站的首选平台。\n\n\n![image.png](https://cdn.nlark.com/yuque/0/2019/png/155457/1546754429532-72508dbe-d330-48e7-ac54-7fcc7e46ab8d.png#align=left&display=inline&height=468&name=image.png&originHeight=468&originWidth=731&size=21435&width=731)\n\n- Linux 操作系统底层\n\n- Apache 服务器，属于次级服务器，沟通Linux和php\n\n- PHP 服务端脚本语言，使用php_module模块与Apache服务器关联，\n\n- Mysql 和 Web Aplication (其他web服务)，使用php_extensions 模块相关联\n\n\n<a name=\"cf4fd8d6\"></a>\n## 二、Apache 生命周期\n\n\n![image.png](https://cdn.nlark.com/yuque/0/2019/png/155457/1546754448409-67737bc7-f0e7-4427-bc45-9fd0cab28236.png#align=left&display=inline&height=479&name=image.png&originHeight=479&originWidth=616&size=47787&width=616)\n\n- 启动阶段：Apache解析配置文件（如http.conf以及Include指令设定的配置文件等），模块加载(例如mod_php.so,mod_perl.so等)和系统资源初始化（例如日志文件、共享内存段等）工作。在这个阶段，Apache为了获得系统资源最大的使用权限，将以特权用户root（X系统）或超级管理员administrator(Windows系统)完成启动。\n\n- 运行阶段：在这个阶段，Apache为了获得系统资源最大的使用权限，将以特权用户root（X系统）或超级管理员administrator(Windows系统)完成启动。分11个阶段处理用户的请求。\n\n\n<a name=\"21182817\"></a>\n## 三、Apache 处理请求的过程\n\n\n![image.png](https://cdn.nlark.com/yuque/0/2019/png/155457/1546754480021-0b01acc1-2578-45f6-ab4d-b68172ac1164.png#align=left&display=inline&height=332&name=image.png&originHeight=406&originWidth=912&size=42743&width=746)\n\n- URI Translation阶段：将请求的URL映射到本地文件系统，mod_alias模块就是在这个阶段工作\n\n- Header Parsing阶段：解析header头部，mod_setenvif在这个阶段工作\n\n- Access Control阶段：按照配置文件设定的策略对用户进行认证，并设定用户名区域，模块可以在这阶段实现认证方法。\n\n- Authorization阶段：根据配置文件检查是否允许认证过的用户执行请求的操作，模块可以在这阶段实现用户权限管理的方法\n\n- MIME Type Checking阶段 ：根据请求资源的MIME类型的相关规则，将文件交由相应的处理模块。\n\n- Fix Up 阶段：模块在内容生成器之前，运行必要的处理流程\n\n- Response阶段 ：生成响应报文。\n\n- Logging阶段 ：在响应客户端后记录事务\n\n- CleanUp阶段 ：清除请求后遗留的环境，如文件、目录的处理或者Socket的关闭等。\n\n\n<a name=\"14d5054c\"></a>\n## 四、Apache 的两种工作模式\n\n<a name=\"0b9352f0\"></a>\n#### 1.什么是MPM\n\nMPM（Multi-Processing Modules，多路处理模块）是Apache的核心组件之一，Apache通过MPM来使用操作系统的资源，对进程和线程池进行管理。Apache为了能够获得更好的运行性能，针对不同的平台 (Unix/Linux、Window)提供了不同的MPM，用户可以根据实际情况进行选择，其中最常使用的MPM有 prefork和worker两种。\n\n<a name=\"2.Prefork\"></a>\n#### 2.Prefork\n\n- 工作原理：Prefork是非线程、预生成进程型MPM，会预先启动一些子进程，每个子进程一个时间只能处理一个请求，并且会根据并发请求数量动态生成更多子进程\n- 配置参数：```\nStartServices    服务器启动默认启动的子进程；\n\nMinSpareServers    最小空闲进程数量；\n\nMaxSpareServers    最大空闲进程数量；\n\nMaxClients     最高的并发量；\n\nServerLimit    最大限制的并发量；\n\nMaxRequestsPerChild      每个子进程默认最多处理多少个请求。当达到设定值时，这个进程就会被kill掉，重新生成一个新的进程（避免内存泄露等安全性问题，运行太久怕出一些bug，可能出现假死，或者占用太多内存等）；\n```\n\n\n<a name=\"3.worker\"></a>\n#### 3.worker\n\n- Workder是线程化、多进程的MPM，每个进程可以生成多个线程，每个线程处理一个请求；不需要启用太多的子进程,每个进程能够拥有的线程数量是固定的。服务器会根据负载情况增加或减少进程数量。一个单独的控制进程(父进程)负责子进程的建立。每个子进程能够建立ThreadsPerChild数量的服务线程和一个监听线程，该监听线程监听接入请求并将其传递给服务线程处理和应答。\n\n- 配置参数：\n```\nStartServers 服务器启动时建立的子进程数，默认值是\"3\"。\n\nMaxClients  允许同时服务的最大接入请求数量(最大线程数量)。任何超过MaxClients限制的请求都将进入等候队列，默认值是\"400\"。\n\nMinSpareThreads 最小空闲线程数,默认值是\"75\"。\n\nMaxSpareThreads  设置最大空闲线程数。默认值是\"250\"。\n\nThreadsPerChild  每个子进程建立的常驻的执行线程数。默认值是25\n\nMaxRequestsPerChild  设置每个子进程在其生存期内允许处理的最大请求数量。\n```\n\n\n<a name=\"28f6842c\"></a>\n#### 4.Prefork和Worker的比较\n\n1. prefork方式速度要稍高于worker，然而它需要的cpu和memory资源也稍多于woker。\n\n2. prefork的无线程设计在某些情况下将比worker更有优势：它可以使用那些没有处理好线程安全的第三方模块，并且对于那些线程调试困难的平台而言，它也更容易调试一些。\n\n3. 在一个高流量的HTTP服务器上，Worker MPM是个比较好的选择，因为Worker MPM的内存使用比Prefork MPM要低得多。\n\n",
    "body_draft": "",
    "body_html": "<p>date: 2017-04-01 23:32:29</p><p>categories: '后端'</p><p>tags: ['Apache','web服务器','后端']</p><hr /><p>Apache是目前世界上使用最为广泛的一种Web Server，它以跨平台、高效和稳定而闻名。那么Apache是怎样工作的呢？</p><p>&lt;!-- more --&gt;</p><h2 id=\"cee624d5\">一、LAMP架构</h2><p><br /></p><p>说起apache，那就不得不了解一下LAMP架构，LAMP架构是较为流行的一套建站架构，因其通用、跨平台、高性能、低价格的优势，无论是性能、质量还是价格都是企业搭建网站的首选平台。</p><p><br /></p><p><br /><img alt=\"image.png\" title=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/155457/1546754429532-72508dbe-d330-48e7-ac54-7fcc7e46ab8d.png#align=left&amp;display=inline&amp;height=468&amp;name=image.png&amp;originHeight=468&amp;originWidth=731&amp;size=21435&amp;width=731\" style=\"max-width: 600px; width: 731px;\" /></p><p><br /></p><ul><li><p>Linux 操作系统底层</p></li></ul><ul><li><p>Apache 服务器，属于次级服务器，沟通Linux和php</p></li></ul><ul><li><p>PHP 服务端脚本语言，使用php_module模块与Apache服务器关联，</p></li></ul><ul><li><p>Mysql 和 Web Aplication (其他web服务)，使用php_extensions 模块相关联</p></li></ul><p><br /></p><h2 id=\"cf4fd8d6\">二、Apache 生命周期</h2><p><br /></p><p><br /><img alt=\"image.png\" title=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/155457/1546754448409-67737bc7-f0e7-4427-bc45-9fd0cab28236.png#align=left&amp;display=inline&amp;height=479&amp;name=image.png&amp;originHeight=479&amp;originWidth=616&amp;size=47787&amp;width=616\" style=\"max-width: 600px; width: 616px;\" /></p><p><br /></p><ul><li><p>启动阶段：Apache解析配置文件（如http.conf以及Include指令设定的配置文件等），模块加载(例如mod_php.so,mod_perl.so等)和系统资源初始化（例如日志文件、共享内存段等）工作。在这个阶段，Apache为了获得系统资源最大的使用权限，将以特权用户root（X系统）或超级管理员administrator(Windows系统)完成启动。</p></li></ul><ul><li><p>运行阶段：在这个阶段，Apache为了获得系统资源最大的使用权限，将以特权用户root（X系统）或超级管理员administrator(Windows系统)完成启动。分11个阶段处理用户的请求。</p></li></ul><p><br /></p><h2 id=\"21182817\">三、Apache 处理请求的过程</h2><p><br /></p><p><br /><img alt=\"image.png\" title=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/155457/1546754480021-0b01acc1-2578-45f6-ab4d-b68172ac1164.png#align=left&amp;display=inline&amp;height=332&amp;name=image.png&amp;originHeight=406&amp;originWidth=912&amp;size=42743&amp;width=746\" style=\"max-width: 600px; width: 746px;\" /></p><ul><li><p>URI Translation阶段：将请求的URL映射到本地文件系统，mod_alias模块就是在这个阶段工作</p></li></ul><ul><li><p>Header Parsing阶段：解析header头部，mod_setenvif在这个阶段工作</p></li></ul><ul><li><p>Access Control阶段：按照配置文件设定的策略对用户进行认证，并设定用户名区域，模块可以在这阶段实现认证方法。</p></li></ul><ul><li><p>Authorization阶段：根据配置文件检查是否允许认证过的用户执行请求的操作，模块可以在这阶段实现用户权限管理的方法</p></li></ul><ul><li><p>MIME Type Checking阶段 ：根据请求资源的MIME类型的相关规则，将文件交由相应的处理模块。</p></li></ul><ul><li><p>Fix Up 阶段：模块在内容生成器之前，运行必要的处理流程</p></li></ul><ul><li><p>Response阶段 ：生成响应报文。</p></li></ul><ul><li><p>Logging阶段 ：在响应客户端后记录事务</p></li></ul><ul><li><p>CleanUp阶段 ：清除请求后遗留的环境，如文件、目录的处理或者Socket的关闭等。</p></li></ul><p><br /></p><h2 id=\"14d5054c\">四、Apache 的两种工作模式</h2><p><br /></p><h4 id=\"0b9352f0\">1.什么是MPM</h4><p><br /></p><p>MPM（Multi-Processing Modules，多路处理模块）是Apache的核心组件之一，Apache通过MPM来使用操作系统的资源，对进程和线程池进行管理。Apache为了能够获得更好的运行性能，针对不同的平台 (Unix/Linux、Window)提供了不同的MPM，用户可以根据实际情况进行选择，其中最常使用的MPM有 prefork和worker两种。</p><p><br /></p><h4 id=\"2.Prefork\">2.Prefork</h4><p><br /></p><ul><li>工作原理：Prefork是非线程、预生成进程型MPM，会预先启动一些子进程，每个子进程一个时间只能处理一个请求，并且会根据并发请求数量动态生成更多子进程</li></ul><ul><li>配置参数：<pre><code>StartServices    服务器启动默认启动的子进程；\n\nMinSpareServers    最小空闲进程数量；\n\nMaxSpareServers    最大空闲进程数量；\n\nMaxClients     最高的并发量；\n\nServerLimit    最大限制的并发量；\n\nMaxRequestsPerChild      每个子进程默认最多处理多少个请求。当达到设定值时，这个进程就会被kill掉，重新生成一个新的进程（避免内存泄露等安全性问题，运行太久怕出一些bug，可能出现假死，或者占用太多内存等）；</code></pre></li></ul><p><br /></p><h4 id=\"3.worker\">3.worker</h4><p><br /></p><ul><li><p>Workder是线程化、多进程的MPM，每个进程可以生成多个线程，每个线程处理一个请求；不需要启用太多的子进程,每个进程能够拥有的线程数量是固定的。服务器会根据负载情况增加或减少进程数量。一个单独的控制进程(父进程)负责子进程的建立。每个子进程能够建立ThreadsPerChild数量的服务线程和一个监听线程，该监听线程监听接入请求并将其传递给服务线程处理和应答。</p></li></ul><ul><li><p>配置参数：</p><pre><code>StartServers 服务器启动时建立的子进程数，默认值是&quot;3&quot;。\n\nMaxClients  允许同时服务的最大接入请求数量(最大线程数量)。任何超过MaxClients限制的请求都将进入等候队列，默认值是&quot;400&quot;。\n\nMinSpareThreads 最小空闲线程数,默认值是&quot;75&quot;。\n\nMaxSpareThreads  设置最大空闲线程数。默认值是&quot;250&quot;。\n\nThreadsPerChild  每个子进程建立的常驻的执行线程数。默认值是25\n\nMaxRequestsPerChild  设置每个子进程在其生存期内允许处理的最大请求数量。</code></pre></li></ul><p><br /></p><h4 id=\"28f6842c\">4.Prefork和Worker的比较</h4><p><br /></p><ol start=\"1\"><li><p>prefork方式速度要稍高于worker，然而它需要的cpu和memory资源也稍多于woker。</p></li></ol><ol start=\"2\"><li><p>prefork的无线程设计在某些情况下将比worker更有优势：它可以使用那些没有处理好线程安全的第三方模块，并且对于那些线程调试困难的平台而言，它也更容易调试一些。</p></li></ol><ol start=\"3\"><li><p>在一个高流量的HTTP服务器上，Worker MPM是个比较好的选择，因为Worker MPM的内存使用比Prefork MPM要低得多。</p></li></ol>",
    "body_lake": "<!doctype lake><p><cursor />date: 2017-04-01 23:32:29</p><p>categories: '后端'</p><p>tags: ['Apache','web服务器','后端']</p><card type=\"block\" name=\"hr\"></card><p>Apache是目前世界上使用最为广泛的一种Web Server，它以跨平台、高效和稳定而闻名。那么Apache是怎样工作的呢？</p><p>&lt;!-- more --&gt;</p><h2 id=\"cee624d5\">一、LAMP架构</h2><p><br /></p><p>说起apache，那就不得不了解一下LAMP架构，LAMP架构是较为流行的一套建站架构，因其通用、跨平台、高性能、低价格的优势，无论是性能、质量还是价格都是企业搭建网站的首选平台。</p><p><br /></p><p><br /><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F155457%2F1546754429532-72508dbe-d330-48e7-ac54-7fcc7e46ab8d.png%22%2C%22originWidth%22%3A731%2C%22originHeight%22%3A468%2C%22name%22%3A%22image.png%22%2C%22size%22%3A21435%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22width%22%3A731%2C%22height%22%3A468%7D\"></card></p><p><br /></p><ul><li><p>Linux 操作系统底层</p></li></ul><ul><li><p>Apache 服务器，属于次级服务器，沟通Linux和php</p></li></ul><ul><li><p>PHP 服务端脚本语言，使用php_module模块与Apache服务器关联，</p></li></ul><ul><li><p>Mysql 和 Web Aplication (其他web服务)，使用php_extensions 模块相关联</p></li></ul><p><br /></p><h2 id=\"cf4fd8d6\">二、Apache 生命周期</h2><p><br /></p><p><br /><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F155457%2F1546754448409-67737bc7-f0e7-4427-bc45-9fd0cab28236.png%22%2C%22originWidth%22%3A616%2C%22originHeight%22%3A479%2C%22name%22%3A%22image.png%22%2C%22size%22%3A47787%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22width%22%3A616%2C%22height%22%3A479%7D\"></card></p><p><br /></p><ul><li><p>启动阶段：Apache解析配置文件（如http.conf以及Include指令设定的配置文件等），模块加载(例如mod_php.so,mod_perl.so等)和系统资源初始化（例如日志文件、共享内存段等）工作。在这个阶段，Apache为了获得系统资源最大的使用权限，将以特权用户root（X系统）或超级管理员administrator(Windows系统)完成启动。</p></li></ul><ul><li><p>运行阶段：在这个阶段，Apache为了获得系统资源最大的使用权限，将以特权用户root（X系统）或超级管理员administrator(Windows系统)完成启动。分11个阶段处理用户的请求。</p></li></ul><p><br /></p><h2 id=\"21182817\">三、Apache 处理请求的过程</h2><p><br /></p><p><br /><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F155457%2F1546754480021-0b01acc1-2578-45f6-ab4d-b68172ac1164.png%22%2C%22originWidth%22%3A912%2C%22originHeight%22%3A406%2C%22name%22%3A%22image.png%22%2C%22size%22%3A42743%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22width%22%3A746%2C%22height%22%3A332%7D\"></card></p><ul><li><p>URI Translation阶段：将请求的URL映射到本地文件系统，mod_alias模块就是在这个阶段工作</p></li></ul><ul><li><p>Header Parsing阶段：解析header头部，mod_setenvif在这个阶段工作</p></li></ul><ul><li><p>Access Control阶段：按照配置文件设定的策略对用户进行认证，并设定用户名区域，模块可以在这阶段实现认证方法。</p></li></ul><ul><li><p>Authorization阶段：根据配置文件检查是否允许认证过的用户执行请求的操作，模块可以在这阶段实现用户权限管理的方法</p></li></ul><ul><li><p>MIME Type Checking阶段 ：根据请求资源的MIME类型的相关规则，将文件交由相应的处理模块。</p></li></ul><ul><li><p>Fix Up 阶段：模块在内容生成器之前，运行必要的处理流程</p></li></ul><ul><li><p>Response阶段 ：生成响应报文。</p></li></ul><ul><li><p>Logging阶段 ：在响应客户端后记录事务</p></li></ul><ul><li><p>CleanUp阶段 ：清除请求后遗留的环境，如文件、目录的处理或者Socket的关闭等。</p></li></ul><p><br /></p><h2 id=\"14d5054c\">四、Apache 的两种工作模式</h2><p><br /></p><h4 id=\"0b9352f0\">1.什么是MPM</h4><p><br /></p><p>MPM（Multi-Processing Modules，多路处理模块）是Apache的核心组件之一，Apache通过MPM来使用操作系统的资源，对进程和线程池进行管理。Apache为了能够获得更好的运行性能，针对不同的平台 (Unix/Linux、Window)提供了不同的MPM，用户可以根据实际情况进行选择，其中最常使用的MPM有 prefork和worker两种。</p><p><br /></p><h4 id=\"2.Prefork\">2.Prefork</h4><p><br /></p><ul><li>工作原理：Prefork是非线程、预生成进程型MPM，会预先启动一些子进程，每个子进程一个时间只能处理一个请求，并且会根据并发请求数量动态生成更多子进程</li></ul><ul><li>配置参数：<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22code%22%3A%22StartServices%20%20%20%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%AF%E5%8A%A8%E9%BB%98%E8%AE%A4%E5%90%AF%E5%8A%A8%E7%9A%84%E5%AD%90%E8%BF%9B%E7%A8%8B%EF%BC%9B%5Cn%5CnMinSpareServers%20%20%20%20%E6%9C%80%E5%B0%8F%E7%A9%BA%E9%97%B2%E8%BF%9B%E7%A8%8B%E6%95%B0%E9%87%8F%EF%BC%9B%5Cn%5CnMaxSpareServers%20%20%20%20%E6%9C%80%E5%A4%A7%E7%A9%BA%E9%97%B2%E8%BF%9B%E7%A8%8B%E6%95%B0%E9%87%8F%EF%BC%9B%5Cn%5CnMaxClients%20%20%20%20%20%E6%9C%80%E9%AB%98%E7%9A%84%E5%B9%B6%E5%8F%91%E9%87%8F%EF%BC%9B%5Cn%5CnServerLimit%20%20%20%20%E6%9C%80%E5%A4%A7%E9%99%90%E5%88%B6%E7%9A%84%E5%B9%B6%E5%8F%91%E9%87%8F%EF%BC%9B%5Cn%5CnMaxRequestsPerChild%20%20%20%20%20%20%E6%AF%8F%E4%B8%AA%E5%AD%90%E8%BF%9B%E7%A8%8B%E9%BB%98%E8%AE%A4%E6%9C%80%E5%A4%9A%E5%A4%84%E7%90%86%E5%A4%9A%E5%B0%91%E4%B8%AA%E8%AF%B7%E6%B1%82%E3%80%82%E5%BD%93%E8%BE%BE%E5%88%B0%E8%AE%BE%E5%AE%9A%E5%80%BC%E6%97%B6%EF%BC%8C%E8%BF%99%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%B0%B1%E4%BC%9A%E8%A2%ABkill%E6%8E%89%EF%BC%8C%E9%87%8D%E6%96%B0%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E8%BF%9B%E7%A8%8B%EF%BC%88%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%AD%89%E5%AE%89%E5%85%A8%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%8C%E8%BF%90%E8%A1%8C%E5%A4%AA%E4%B9%85%E6%80%95%E5%87%BA%E4%B8%80%E4%BA%9Bbug%EF%BC%8C%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E5%81%87%E6%AD%BB%EF%BC%8C%E6%88%96%E8%80%85%E5%8D%A0%E7%94%A8%E5%A4%AA%E5%A4%9A%E5%86%85%E5%AD%98%E7%AD%89%EF%BC%89%EF%BC%9B%22%7D\"></card></li></ul><p><br /></p><h4 id=\"3.worker\">3.worker</h4><p><br /></p><ul><li><p>Workder是线程化、多进程的MPM，每个进程可以生成多个线程，每个线程处理一个请求；不需要启用太多的子进程,每个进程能够拥有的线程数量是固定的。服务器会根据负载情况增加或减少进程数量。一个单独的控制进程(父进程)负责子进程的建立。每个子进程能够建立ThreadsPerChild数量的服务线程和一个监听线程，该监听线程监听接入请求并将其传递给服务线程处理和应答。</p></li></ul><ul><li><p>配置参数：</p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22code%22%3A%22StartServers%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%AF%E5%8A%A8%E6%97%B6%E5%BB%BA%E7%AB%8B%E7%9A%84%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%95%B0%EF%BC%8C%E9%BB%98%E8%AE%A4%E5%80%BC%E6%98%AF%5C%223%5C%22%E3%80%82%5Cn%5CnMaxClients%20%20%E5%85%81%E8%AE%B8%E5%90%8C%E6%97%B6%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9C%80%E5%A4%A7%E6%8E%A5%E5%85%A5%E8%AF%B7%E6%B1%82%E6%95%B0%E9%87%8F(%E6%9C%80%E5%A4%A7%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F)%E3%80%82%E4%BB%BB%E4%BD%95%E8%B6%85%E8%BF%87MaxClients%E9%99%90%E5%88%B6%E7%9A%84%E8%AF%B7%E6%B1%82%E9%83%BD%E5%B0%86%E8%BF%9B%E5%85%A5%E7%AD%89%E5%80%99%E9%98%9F%E5%88%97%EF%BC%8C%E9%BB%98%E8%AE%A4%E5%80%BC%E6%98%AF%5C%22400%5C%22%E3%80%82%5Cn%5CnMinSpareThreads%20%E6%9C%80%E5%B0%8F%E7%A9%BA%E9%97%B2%E7%BA%BF%E7%A8%8B%E6%95%B0%2C%E9%BB%98%E8%AE%A4%E5%80%BC%E6%98%AF%5C%2275%5C%22%E3%80%82%5Cn%5CnMaxSpareThreads%20%20%E8%AE%BE%E7%BD%AE%E6%9C%80%E5%A4%A7%E7%A9%BA%E9%97%B2%E7%BA%BF%E7%A8%8B%E6%95%B0%E3%80%82%E9%BB%98%E8%AE%A4%E5%80%BC%E6%98%AF%5C%22250%5C%22%E3%80%82%5Cn%5CnThreadsPerChild%20%20%E6%AF%8F%E4%B8%AA%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%BB%BA%E7%AB%8B%E7%9A%84%E5%B8%B8%E9%A9%BB%E7%9A%84%E6%89%A7%E8%A1%8C%E7%BA%BF%E7%A8%8B%E6%95%B0%E3%80%82%E9%BB%98%E8%AE%A4%E5%80%BC%E6%98%AF25%5Cn%5CnMaxRequestsPerChild%20%20%E8%AE%BE%E7%BD%AE%E6%AF%8F%E4%B8%AA%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%9C%A8%E5%85%B6%E7%94%9F%E5%AD%98%E6%9C%9F%E5%86%85%E5%85%81%E8%AE%B8%E5%A4%84%E7%90%86%E7%9A%84%E6%9C%80%E5%A4%A7%E8%AF%B7%E6%B1%82%E6%95%B0%E9%87%8F%E3%80%82%22%7D\"></card></li></ul><p><br /></p><h4 id=\"28f6842c\">4.Prefork和Worker的比较</h4><p><br /></p><ol start=\"1\"><li><p>prefork方式速度要稍高于worker，然而它需要的cpu和memory资源也稍多于woker。</p></li></ol><ol start=\"2\"><li><p>prefork的无线程设计在某些情况下将比worker更有优势：它可以使用那些没有处理好线程安全的第三方模块，并且对于那些线程调试困难的平台而言，它也更容易调试一些。</p></li></ol><ol start=\"3\"><li><p>在一个高流量的HTTP服务器上，Worker MPM是个比较好的选择，因为Worker MPM的内存使用比Prefork MPM要低得多。</p></li></ol>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-01-14T03:01:50.000Z",
    "deleted_at": null,
    "created_at": "2019-01-06T05:58:45.000Z",
    "updated_at": "2019-01-14T03:01:50.000Z",
    "published_at": "2019-01-14T03:01:50.000Z",
    "first_published_at": "2019-01-06T06:01:54.000Z",
    "word_count": 1381,
    "cover": null,
    "description": "date: 2017-04-01 23:32:29categories: '后端'tags: ['Apache','web服务器','后端']Apache是目前世界上使用最为广泛的一种Web Server，它以跨平台、高效和稳定而闻名。那么Apache是怎样工作的呢？&lt;!-- more ...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1116539,
    "slug": "kegs8b",
    "title": "无标题",
    "book_id": 199054,
    "book": {
      "id": 199054,
      "type": "Book",
      "slug": "blog",
      "name": "博客",
      "user_id": 155457,
      "description": "前端技术博客存档",
      "creator_id": 155457,
      "public": 1,
      "items_count": 15,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-04-23T09:00:45.336Z",
      "updated_at": "2019-04-23T09:00:45.000Z",
      "created_at": "2019-01-06T05:57:32.000Z",
      "namespace": "u46795/blog",
      "user": {
        "id": 155457,
        "type": "User",
        "login": "u46795",
        "name": "Nero",
        "description": "https://github.com/Ghostdar",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 5,
        "public_books_count": 5,
        "followers_count": 12,
        "following_count": 5,
        "created_at": "2018-08-04T03:45:56.000Z",
        "updated_at": "2019-04-30T15:08:36.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 155457,
    "creator": {
      "id": 155457,
      "type": "User",
      "login": "u46795",
      "name": "Nero",
      "description": "https://github.com/Ghostdar",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/155457/1540197600172-10ac7149-7e24-41e1-9006-27d3925a4e33.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 5,
      "public_books_count": 5,
      "followers_count": 12,
      "following_count": 5,
      "created_at": "2018-08-04T03:45:56.000Z",
      "updated_at": "2019-04-30T15:08:36.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "",
    "body_draft": "",
    "body_html": "",
    "body_lake": "",
    "public": 1,
    "status": 0,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-01-06T05:57:50.000Z",
    "deleted_at": null,
    "created_at": "2019-01-06T05:57:50.000Z",
    "updated_at": "2019-01-06T05:57:50.000Z",
    "published_at": null,
    "first_published_at": null,
    "word_count": 0,
    "cover": null,
    "description": "",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1731870,
    "slug": "vkg389",
    "title": "你好hello",
    "book_id": 308028,
    "book": {
      "id": 308028,
      "type": "Book",
      "slug": "charles-blog",
      "name": "charles-blog",
      "user_id": 353332,
      "description": "",
      "creator_id": 353332,
      "public": 1,
      "items_count": 1,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-05-21T08:58:42.308Z",
      "updated_at": "2019-05-21T09:21:57.000Z",
      "created_at": "2019-05-21T08:57:57.000Z",
      "namespace": "mumucat/charles-blog",
      "user": {
        "id": 353332,
        "type": "User",
        "login": "mumucat",
        "name": "mumu",
        "description": null,
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1558407816189-35c15955-b79c-4dce-9be7-4426a63594af.jpeg",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1558407816189-35c15955-b79c-4dce-9be7-4426a63594af.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1558407816189-35c15955-b79c-4dce-9be7-4426a63594af.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1558407816189-35c15955-b79c-4dce-9be7-4426a63594af.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 2,
        "followers_count": 0,
        "following_count": 0,
        "created_at": "2019-05-21T03:10:18.000Z",
        "updated_at": "2019-05-21T09:23:38.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 353332,
    "creator": {
      "id": 353332,
      "type": "User",
      "login": "mumucat",
      "name": "mumu",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1558407816189-35c15955-b79c-4dce-9be7-4426a63594af.jpeg",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1558407816189-35c15955-b79c-4dce-9be7-4426a63594af.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1558407816189-35c15955-b79c-4dce-9be7-4426a63594af.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1558407816189-35c15955-b79c-4dce-9be7-4426a63594af.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 2,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2019-05-21T03:10:18.000Z",
      "updated_at": "2019-05-21T09:23:38.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "Website\n\n程序员的设计课系列blog\n\n设计师的设计课系列\n\nDesign system CSS framework\n\nSketch pluginss\n\nUser research\n\nDesign sprint\n\n\t确定分享会主题与目标<br />\t画出路线图\n\n",
    "body_draft": "",
    "body_html": "<p><span class=\"lake-fontsize-11\" style=\"color: #000000; background-color: transparent;\">Website</span></p><p><br /></p><p><span class=\"lake-fontsize-11\" style=\"color: #000000; background-color: transparent;\">程序员的设计课系列blog</span></p><p><br /></p><p><span class=\"lake-fontsize-11\" style=\"color: #000000; background-color: transparent;\">设计师的设计课系列</span></p><p><br /></p><p><span class=\"lake-fontsize-11\" style=\"color: #000000; background-color: transparent;\">Design system CSS framework</span></p><p><br /></p><p><span class=\"lake-fontsize-11\" style=\"color: #000000; background-color: transparent;\">Sketch pluginss</span></p><p><br /></p><p><span class=\"lake-fontsize-11\" style=\"color: #000000; background-color: transparent;\">User research</span></p><p><br /></p><p><span class=\"lake-fontsize-11\" style=\"color: #000000; background-color: transparent;\">Design sprint</span></p><p><br /></p><p><span class=\"lake-fontsize-11\" style=\"color: #000000; background-color: transparent;\">\t</span><span class=\"lake-fontsize-11\" style=\"color: #000000; background-color: transparent;\">确定分享会主题与目标</span></p><p><span class=\"lake-fontsize-11\" style=\"color: #000000; background-color: transparent;\">\t</span><span class=\"lake-fontsize-11\" style=\"color: #000000; background-color: transparent;\">画出路线图</span></p><p><br /></p>",
    "body_lake": "<!doctype lake><p><span class=\"lake-fontsize-11\" style=\"color: #000000; background-color: transparent;\">Website</span></p><p><br /></p><p><span class=\"lake-fontsize-11\" style=\"color: #000000; background-color: transparent;\">程序员的设计课系列blog</span></p><p><br /></p><p><span class=\"lake-fontsize-11\" style=\"color: #000000; background-color: transparent;\">设计师的设计课系列</span></p><p><br /></p><p><span class=\"lake-fontsize-11\" style=\"color: #000000; background-color: transparent;\">Design system CSS framework</span></p><p><br /></p><p><span class=\"lake-fontsize-11\" style=\"color: #000000; background-color: transparent;\">Sketch pluginss</span></p><p><br /></p><p><span class=\"lake-fontsize-11\" style=\"color: #000000; background-color: transparent;\">User research</span></p><p><br /></p><p><span class=\"lake-fontsize-11\" style=\"color: #000000; background-color: transparent;\">Design sprint</span></p><p><br /></p><p><span class=\"lake-fontsize-11\" style=\"color: #000000; background-color: transparent;\">\t</span><span class=\"lake-fontsize-11\" style=\"color: #000000; background-color: transparent;\">确定分享会主题与目标</span></p><p><span class=\"lake-fontsize-11\" style=\"color: #000000; background-color: transparent;\">\t</span><span class=\"lake-fontsize-11\" style=\"color: #000000; background-color: transparent;\">画出路线图</span></p><p><br /><cursor /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-05-21T08:58:42.000Z",
    "deleted_at": null,
    "created_at": "2019-05-21T08:58:16.000Z",
    "updated_at": "2019-05-21T08:58:42.000Z",
    "published_at": "2019-05-21T08:58:42.000Z",
    "first_published_at": "2019-05-21T08:58:42.000Z",
    "word_count": 45,
    "cover": null,
    "description": "Website程序员的设计课系列blog设计师的设计课系列Design system CSS frameworkSketch pluginssUser researchDesign sprint\t确定分享会主题与目标\t画出路线图",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  }
]